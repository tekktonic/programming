//
// This file was auto-generated, do not edit directly
//

/*
Copyright © 2008-2011 Kristian Høgsberg
    Copyright © 2010-2011 Intel Corporation
    Copyright © 2012-2013 Collabora, Ltd.

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice (including the
    next paragraph) shall be included in all copies or substantial
    portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

use wayland_sys::common::*;
use wayland_sys::client::*;
use {Proxy, ProxyId, wrap_proxy};
use events::{EventIterator, EventFifo, get_eventiter_internals, eventiter_from_internals};
// update if needed to the appropriate file
use super::interfaces::*;

use std::ffi::{CString, CStr};
use std::ptr;
use std::sync::Arc;
use std::sync::atomic::{AtomicBool, Ordering};
use std::os::raw::{c_void, c_char};
/// An event generated by the protocol wayland.
///
/// Each variant is composed of a `ProxyId` reffering to the proxy object
/// and of the event data itself.
#[derive(Debug)]
pub enum WaylandProtocolEvent {
    WlDisplay(ProxyId, WlDisplayEvent),
    WlRegistry(ProxyId, WlRegistryEvent),
    WlCallback(ProxyId, WlCallbackEvent),
    WlShm(ProxyId, WlShmEvent),
    WlBuffer(ProxyId, WlBufferEvent),
    WlDataOffer(ProxyId, WlDataOfferEvent),
    WlDataSource(ProxyId, WlDataSourceEvent),
    WlDataDevice(ProxyId, WlDataDeviceEvent),
    WlShellSurface(ProxyId, WlShellSurfaceEvent),
    WlSurface(ProxyId, WlSurfaceEvent),
    WlSeat(ProxyId, WlSeatEvent),
    WlPointer(ProxyId, WlPointerEvent),
    WlKeyboard(ProxyId, WlKeyboardEvent),
    WlTouch(ProxyId, WlTouchEvent),
    WlOutput(ProxyId, WlOutputEvent),
}

type wayland_dispatcher_implem = fn(*mut wl_proxy, u32, *const wl_argument) -> Option<WaylandProtocolEvent>;

extern "C" fn event_dispatcher(implem: *const c_void, proxy: *mut c_void, opcode: u32, _: *const wl_message, args: *const wl_argument) {
    let userdata = unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_get_user_data, proxy as *mut wl_proxy) } as *const (EventFifo, AtomicBool);
    if userdata.is_null() { return; }
    let fifo: &(EventFifo, AtomicBool) = unsafe { &*userdata };
    if !fifo.1.load(Ordering::SeqCst) { return; }
    let implem = unsafe { ::std::mem::transmute::<_, wayland_dispatcher_implem>(implem) };
    let event = implem(proxy as *mut wl_proxy, opcode, args);
    if let Some(evt) = event {
        fifo.0.push(::Event::Wayland(evt));
    }
}
//
// interface wl_display
//

/// core global object
///
/// The core global object.  This is a special singleton object.  It
/// is used for internal Wayland protocol features.
pub struct WlDisplay {
    ptr: *mut wl_proxy,
    evq: Arc<(EventFifo,AtomicBool)>
}

unsafe impl Sync for WlDisplay {}
unsafe impl Send for WlDisplay {}
impl Proxy for WlDisplay {
    fn ptr(&self) -> *mut wl_proxy { self.ptr }
    fn interface() -> *mut wl_interface { unsafe { &mut wl_display_interface  as *mut wl_interface } }
    fn interface_name() -> &'static str { "wl_display" }
    fn version() -> u32 { 1 }
    fn id(&self) -> ProxyId { ProxyId { id: self.ptr as usize } }
    unsafe fn from_ptr(ptr: *mut wl_proxy) -> WlDisplay {
        WlDisplay { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    unsafe fn from_ptr_no_own(ptr: *mut wl_proxy) -> WlDisplay {
        WlDisplay { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    fn set_evt_iterator(&mut self, evt: &EventIterator) {
        self.evq = get_eventiter_internals(evt);
    }
}

impl ::std::fmt::Debug for WlDisplay {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {
        fmt.write_fmt(format_args!("wayland::wl_display::{}", self.ptr as usize))
    }
}

/// global error values
///
/// These errors are global and can be emitted in response to any
/// server request.
#[repr(u32)]
#[derive(Debug)]
pub enum WlDisplayError {
    /// server couldn't find object
    InvalidObject = 0,
    /// method doesn't exist on the specified interface
    InvalidMethod = 1,
    /// server is out of memory
    NoMemory = 2,
}
fn wl_display_error_from_raw(n: u32) -> Option<WlDisplayError> {
    match n {
        0 => Some(WlDisplayError::InvalidObject),
        1 => Some(WlDisplayError::InvalidMethod),
        2 => Some(WlDisplayError::NoMemory),
        _ => None
    }
}

// wl_display opcodes
const WL_DISPLAY_SYNC: u32 = 0;
const WL_DISPLAY_GET_REGISTRY: u32 = 1;

#[derive(Debug)]
pub enum WlDisplayEvent {
    /// fatal error event
    ///
    /// The error event is sent out when a fatal (non-recoverable)
    /// error has occurred.  The object_id argument is the object
    /// where the error occurred, most often in response to a request
    /// to that object.  The code identifies the error and is defined
    /// by the object interface.  As such, each interface defines its
    /// own set of error codes.  The message is an brief description
    /// of the error, for (debugging) convenience.
    ///
    /// Values: object_id, code, message,
    Error(ProxyId,u32,String,),
    /// acknowledge object ID deletion
    ///
    /// This event is used internally by the object ID management
    /// logic.  When a client deletes an object, the server will send
    /// this event to acknowledge that it has seen the delete request.
    /// When the client receive this event, it will know that it can
    /// safely reuse the object ID.
    ///
    /// Values: id,
    DeleteId(u32,),
}

fn wl_display_implem(proxy: *mut wl_proxy, opcode: u32, args: *const wl_argument) -> Option<WaylandProtocolEvent> {
    let event = match opcode {
        0 => {
            let arg_0 = unsafe {wrap_proxy(*(args.offset(0) as *const *mut wl_proxy))};
            let arg_1 = unsafe {*(args.offset(1) as *const u32)};
            let arg_2 = unsafe {String::from_utf8_lossy(CStr::from_ptr(*(args.offset(2) as *const *mut c_char)).to_bytes()).into_owned()};
            Some(WlDisplayEvent::Error(arg_0,arg_1,arg_2,))
        },
        1 => {
            let arg_0 = unsafe {*(args.offset(0) as *const u32)};
            Some(WlDisplayEvent::DeleteId(arg_0,))
        },
        _ => None
    };
    event.map(|event| WaylandProtocolEvent::WlDisplay(wrap_proxy(proxy), event))
}

impl WlDisplay {

    /// asynchronous roundtrip
    ///
    /// The sync request asks the server to emit the 'done' event
    /// on the returned wl_callback object.  Since requests are
    /// handled in-order and events are delivered in-order, this can
    /// be used as a barrier to ensure all previous requests and the
    /// resulting events have been handled.
    ///
    /// The object returned by this request will be destroyed by the
    /// compositor after the callback is fired and as such the client must not
    /// attempt to use it after that point.
    ///
    /// The callback_data passed in the callback is the event serial.
    pub fn sync(&self,) -> WlCallback {
        let ptr = unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal_constructor, self.ptr(), WL_DISPLAY_SYNC, &wl_callback_interface as *const wl_interface
           , ptr::null_mut::<wl_proxy>()) };
        let mut proxy: WlCallback = unsafe { Proxy::from_ptr(ptr) };
        let evt_iter = eventiter_from_internals(self.evq.clone());
        proxy.set_evt_iterator(&evt_iter);
        ::std::mem::forget(evt_iter); // Don't run the destructor !
        proxy
    }

    /// get global registry object
    ///
    /// This request creates a registry object that allows the client
    /// to list and bind the global objects available from the
    /// compositor.
    pub fn get_registry(&self,) -> WlRegistry {
        let ptr = unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal_constructor, self.ptr(), WL_DISPLAY_GET_REGISTRY, &wl_registry_interface as *const wl_interface
           , ptr::null_mut::<wl_proxy>()) };
        let mut proxy: WlRegistry = unsafe { Proxy::from_ptr(ptr) };
        let evt_iter = eventiter_from_internals(self.evq.clone());
        proxy.set_evt_iterator(&evt_iter);
        ::std::mem::forget(evt_iter); // Don't run the destructor !
        proxy
    }
}

//
// interface wl_registry
//

/// global registry object
///
/// The global registry object.  The server has a number of global
/// objects that are available to all clients.  These objects
/// typically represent an actual object in the server (for example,
/// an input device) or they are singleton objects that provide
/// extension functionality.
///
/// When a client creates a registry object, the registry object
/// will emit a global event for each global currently in the
/// registry.  Globals come and go as a result of device or
/// monitor hotplugs, reconfiguration or other events, and the
/// registry will send out global and global_remove events to
/// keep the client up to date with the changes.  To mark the end
/// of the initial burst of events, the client can use the
/// wl_display.sync request immediately after calling
/// wl_display.get_registry.
///
/// A client can bind to a global object by using the bind
/// request.  This creates a client-side handle that lets the object
/// emit events to the client and lets the client invoke requests on
/// the object.
pub struct WlRegistry {
    ptr: *mut wl_proxy,
    evq: Arc<(EventFifo,AtomicBool)>
}

unsafe impl Sync for WlRegistry {}
unsafe impl Send for WlRegistry {}
impl Proxy for WlRegistry {
    fn ptr(&self) -> *mut wl_proxy { self.ptr }
    fn interface() -> *mut wl_interface { unsafe { &mut wl_registry_interface  as *mut wl_interface } }
    fn interface_name() -> &'static str { "wl_registry" }
    fn version() -> u32 { 1 }
    fn id(&self) -> ProxyId { ProxyId { id: self.ptr as usize } }
    unsafe fn from_ptr(ptr: *mut wl_proxy) -> WlRegistry {
        ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_add_dispatcher, ptr, event_dispatcher, wl_registry_implem as *const c_void, ptr::null_mut());
        WlRegistry { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    unsafe fn from_ptr_no_own(ptr: *mut wl_proxy) -> WlRegistry {
        WlRegistry { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    fn set_evt_iterator(&mut self, evt: &EventIterator) {
        self.evq = get_eventiter_internals(evt);
        let ptr = &*self.evq as *const (EventFifo,AtomicBool);
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_set_user_data, self.ptr, ptr as *const c_void as *mut c_void) };
    }
}

impl ::std::fmt::Debug for WlRegistry {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {
        fmt.write_fmt(format_args!("wayland::wl_registry::{}", self.ptr as usize))
    }
}

// wl_registry opcodes
const WL_REGISTRY_BIND: u32 = 0;

#[derive(Debug)]
pub enum WlRegistryEvent {
    /// announce global object
    ///
    /// Notify the client of global objects.
    ///
    /// The event notifies the client that a global object with
    /// the given name is now available, and it implements the
    /// given version of the given interface.
    ///
    /// Values: name, interface, version,
    Global(u32,String,u32,),
    /// announce removal of global object
    ///
    /// Notify the client of removed global objects.
    ///
    /// This event notifies the client that the global identified
    /// by name is no longer available.  If the client bound to
    /// the global using the bind request, the client should now
    /// destroy that object.
    ///
    /// The object remains valid and requests to the object will be
    /// ignored until the client destroys it, to avoid races between
    /// the global going away and a client sending a request to it.
    ///
    /// Values: name,
    GlobalRemove(u32,),
}

fn wl_registry_implem(proxy: *mut wl_proxy, opcode: u32, args: *const wl_argument) -> Option<WaylandProtocolEvent> {
    let event = match opcode {
        0 => {
            let arg_0 = unsafe {*(args.offset(0) as *const u32)};
            let arg_1 = unsafe {String::from_utf8_lossy(CStr::from_ptr(*(args.offset(1) as *const *mut c_char)).to_bytes()).into_owned()};
            let arg_2 = unsafe {*(args.offset(2) as *const u32)};
            Some(WlRegistryEvent::Global(arg_0,arg_1,arg_2,))
        },
        1 => {
            let arg_0 = unsafe {*(args.offset(0) as *const u32)};
            Some(WlRegistryEvent::GlobalRemove(arg_0,))
        },
        _ => None
    };
    event.map(|event| WaylandProtocolEvent::WlRegistry(wrap_proxy(proxy), event))
}

impl WlRegistry {

    /// bind an object to the display
    ///
    /// Binds a new, client-created object to the server using the
    /// specified name as the identifier.
    pub unsafe fn bind<T: Proxy>(&self, name: u32,version: u32,) -> T {
        if version > <T as Proxy>::version() {
            panic!("Tried to bind interface {} with version {} while it is only supported up to {}.", <T as Proxy>::interface_name(), version, <T as Proxy>::version())
        }
        let ptr = unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal_constructor, self.ptr(), WL_REGISTRY_BIND, <T as Proxy>::interface()
           , name, (*<T as Proxy>::interface()).name, version, ptr::null_mut::<wl_proxy>()) };
        let mut proxy: T = unsafe { Proxy::from_ptr(ptr) };
        let evt_iter = eventiter_from_internals(self.evq.clone());
        proxy.set_evt_iterator(&evt_iter);
        ::std::mem::forget(evt_iter); // Don't run the destructor !
        proxy
    }
}

impl Drop for WlRegistry {
    fn drop(&mut self) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_destroy, self.ptr()) }
    }
}
//
// interface wl_callback
//

/// callback object
///
/// Clients can handle the 'done' event to get notified when
/// the related request is done.
pub struct WlCallback {
    ptr: *mut wl_proxy,
    evq: Arc<(EventFifo,AtomicBool)>
}

unsafe impl Sync for WlCallback {}
unsafe impl Send for WlCallback {}
impl Proxy for WlCallback {
    fn ptr(&self) -> *mut wl_proxy { self.ptr }
    fn interface() -> *mut wl_interface { unsafe { &mut wl_callback_interface  as *mut wl_interface } }
    fn interface_name() -> &'static str { "wl_callback" }
    fn version() -> u32 { 1 }
    fn id(&self) -> ProxyId { ProxyId { id: self.ptr as usize } }
    unsafe fn from_ptr(ptr: *mut wl_proxy) -> WlCallback {
        ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_add_dispatcher, ptr, event_dispatcher, wl_callback_implem as *const c_void, ptr::null_mut());
        WlCallback { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    unsafe fn from_ptr_no_own(ptr: *mut wl_proxy) -> WlCallback {
        WlCallback { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    fn set_evt_iterator(&mut self, evt: &EventIterator) {
        self.evq = get_eventiter_internals(evt);
        let ptr = &*self.evq as *const (EventFifo,AtomicBool);
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_set_user_data, self.ptr, ptr as *const c_void as *mut c_void) };
    }
}

impl ::std::fmt::Debug for WlCallback {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {
        fmt.write_fmt(format_args!("wayland::wl_callback::{}", self.ptr as usize))
    }
}

// wl_callback opcodes
#[derive(Debug)]
pub enum WlCallbackEvent {
    /// done event
    ///
    /// Notify the client when the related request is done.
    ///
    /// Values: callback_data,
    Done(u32,),
}

fn wl_callback_implem(proxy: *mut wl_proxy, opcode: u32, args: *const wl_argument) -> Option<WaylandProtocolEvent> {
    let event = match opcode {
        0 => {
            let arg_0 = unsafe {*(args.offset(0) as *const u32)};
            Some(WlCallbackEvent::Done(arg_0,))
        },
        _ => None
    };
    event.map(|event| WaylandProtocolEvent::WlCallback(wrap_proxy(proxy), event))
}

impl WlCallback {
}

impl Drop for WlCallback {
    fn drop(&mut self) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_destroy, self.ptr()) }
    }
}
//
// interface wl_compositor
//

/// the compositor singleton
///
/// A compositor.  This object is a singleton global.  The
/// compositor is in charge of combining the contents of multiple
/// surfaces into one displayable output.
pub struct WlCompositor {
    ptr: *mut wl_proxy,
    evq: Arc<(EventFifo,AtomicBool)>
}

unsafe impl Sync for WlCompositor {}
unsafe impl Send for WlCompositor {}
impl Proxy for WlCompositor {
    fn ptr(&self) -> *mut wl_proxy { self.ptr }
    fn interface() -> *mut wl_interface { unsafe { &mut wl_compositor_interface  as *mut wl_interface } }
    fn interface_name() -> &'static str { "wl_compositor" }
    fn version() -> u32 { 3 }
    fn id(&self) -> ProxyId { ProxyId { id: self.ptr as usize } }
    unsafe fn from_ptr(ptr: *mut wl_proxy) -> WlCompositor {
        WlCompositor { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    unsafe fn from_ptr_no_own(ptr: *mut wl_proxy) -> WlCompositor {
        WlCompositor { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    fn set_evt_iterator(&mut self, evt: &EventIterator) {
        self.evq = get_eventiter_internals(evt);
        let ptr = &*self.evq as *const (EventFifo,AtomicBool);
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_set_user_data, self.ptr, ptr as *const c_void as *mut c_void) };
    }
}

impl ::std::fmt::Debug for WlCompositor {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {
        fmt.write_fmt(format_args!("wayland::wl_compositor::{}", self.ptr as usize))
    }
}

// wl_compositor opcodes
const WL_COMPOSITOR_CREATE_SURFACE: u32 = 0;
const WL_COMPOSITOR_CREATE_REGION: u32 = 1;

impl WlCompositor {

    /// create new surface
    ///
    /// Ask the compositor to create a new surface.
    pub fn create_surface(&self,) -> WlSurface {
        let ptr = unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal_constructor, self.ptr(), WL_COMPOSITOR_CREATE_SURFACE, &wl_surface_interface as *const wl_interface
           , ptr::null_mut::<wl_proxy>()) };
        let mut proxy: WlSurface = unsafe { Proxy::from_ptr(ptr) };
        let evt_iter = eventiter_from_internals(self.evq.clone());
        proxy.set_evt_iterator(&evt_iter);
        ::std::mem::forget(evt_iter); // Don't run the destructor !
        proxy
    }

    /// create new region
    ///
    /// Ask the compositor to create a new region.
    pub fn create_region(&self,) -> WlRegion {
        let ptr = unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal_constructor, self.ptr(), WL_COMPOSITOR_CREATE_REGION, &wl_region_interface as *const wl_interface
           , ptr::null_mut::<wl_proxy>()) };
        let mut proxy: WlRegion = unsafe { Proxy::from_ptr(ptr) };
        let evt_iter = eventiter_from_internals(self.evq.clone());
        proxy.set_evt_iterator(&evt_iter);
        ::std::mem::forget(evt_iter); // Don't run the destructor !
        proxy
    }
}

impl Drop for WlCompositor {
    fn drop(&mut self) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_destroy, self.ptr()) }
    }
}
//
// interface wl_shm_pool
//

/// a shared memory pool
///
/// The wl_shm_pool object encapsulates a piece of memory shared
/// between the compositor and client.  Through the wl_shm_pool
/// object, the client can allocate shared memory wl_buffer objects.
/// All objects created through the same pool share the same
/// underlying mapped memory. Reusing the mapped memory avoids the
/// setup/teardown overhead and is useful when interactively resizing
/// a surface or for many small buffers.
pub struct WlShmPool {
    ptr: *mut wl_proxy,
    evq: Arc<(EventFifo,AtomicBool)>
}

unsafe impl Sync for WlShmPool {}
unsafe impl Send for WlShmPool {}
impl Proxy for WlShmPool {
    fn ptr(&self) -> *mut wl_proxy { self.ptr }
    fn interface() -> *mut wl_interface { unsafe { &mut wl_shm_pool_interface  as *mut wl_interface } }
    fn interface_name() -> &'static str { "wl_shm_pool" }
    fn version() -> u32 { 1 }
    fn id(&self) -> ProxyId { ProxyId { id: self.ptr as usize } }
    unsafe fn from_ptr(ptr: *mut wl_proxy) -> WlShmPool {
        WlShmPool { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    unsafe fn from_ptr_no_own(ptr: *mut wl_proxy) -> WlShmPool {
        WlShmPool { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    fn set_evt_iterator(&mut self, evt: &EventIterator) {
        self.evq = get_eventiter_internals(evt);
        let ptr = &*self.evq as *const (EventFifo,AtomicBool);
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_set_user_data, self.ptr, ptr as *const c_void as *mut c_void) };
    }
}

impl ::std::fmt::Debug for WlShmPool {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {
        fmt.write_fmt(format_args!("wayland::wl_shm_pool::{}", self.ptr as usize))
    }
}

// wl_shm_pool opcodes
const WL_SHM_POOL_CREATE_BUFFER: u32 = 0;
const WL_SHM_POOL_DESTROY: u32 = 1;
const WL_SHM_POOL_RESIZE: u32 = 2;

impl WlShmPool {

    /// create a buffer from the pool
    ///
    /// Create a wl_buffer object from the pool.
    ///
    /// The buffer is created offset bytes into the pool and has
    /// width and height as specified.  The stride arguments specifies
    /// the number of bytes from beginning of one row to the beginning
    /// of the next.  The format is the pixel format of the buffer and
    /// must be one of those advertised through the wl_shm.format event.
    ///
    /// A buffer will keep a reference to the pool it was created from
    /// so it is valid to destroy the pool immediately after creating
    /// a buffer from it.
    pub fn create_buffer(&self, offset: i32, width: i32, height: i32, stride: i32, format: u32,) -> WlBuffer {
        let ptr = unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal_constructor, self.ptr(), WL_SHM_POOL_CREATE_BUFFER, &wl_buffer_interface as *const wl_interface
           , ptr::null_mut::<wl_proxy>(), offset, width, height, stride, format) };
        let mut proxy: WlBuffer = unsafe { Proxy::from_ptr(ptr) };
        let evt_iter = eventiter_from_internals(self.evq.clone());
        proxy.set_evt_iterator(&evt_iter);
        ::std::mem::forget(evt_iter); // Don't run the destructor !
        proxy
    }

    /// destroy the pool
    ///
    /// Destroy the shared memory pool.
    ///
    /// The mmapped memory will be released when all
    /// buffers that have been created from this pool
    /// are gone.
    pub fn destroy(self,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_SHM_POOL_DESTROY
           ) };
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_destroy, self.ptr()) }
    }

    /// change the size of the pool mapping
    ///
    /// This request will cause the server to remap the backing memory
    /// for the pool from the file descriptor passed when the pool was
    /// created, but using the new size.  This request can only be
    /// used to make the pool bigger.
    pub fn resize(&self, size: i32,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_SHM_POOL_RESIZE
           , size) };
    }
}

impl Drop for WlShmPool {
    fn drop(&mut self) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_destroy, self.ptr()) }
    }
}
//
// interface wl_shm
//

/// shared memory support
///
/// A global singleton object that provides support for shared
/// memory.
///
/// Clients can create wl_shm_pool objects using the create_pool
/// request.
///
/// At connection setup time, the wl_shm object emits one or more
/// format events to inform clients about the valid pixel formats
/// that can be used for buffers.
pub struct WlShm {
    ptr: *mut wl_proxy,
    evq: Arc<(EventFifo,AtomicBool)>
}

unsafe impl Sync for WlShm {}
unsafe impl Send for WlShm {}
impl Proxy for WlShm {
    fn ptr(&self) -> *mut wl_proxy { self.ptr }
    fn interface() -> *mut wl_interface { unsafe { &mut wl_shm_interface  as *mut wl_interface } }
    fn interface_name() -> &'static str { "wl_shm" }
    fn version() -> u32 { 1 }
    fn id(&self) -> ProxyId { ProxyId { id: self.ptr as usize } }
    unsafe fn from_ptr(ptr: *mut wl_proxy) -> WlShm {
        ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_add_dispatcher, ptr, event_dispatcher, wl_shm_implem as *const c_void, ptr::null_mut());
        WlShm { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    unsafe fn from_ptr_no_own(ptr: *mut wl_proxy) -> WlShm {
        WlShm { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    fn set_evt_iterator(&mut self, evt: &EventIterator) {
        self.evq = get_eventiter_internals(evt);
        let ptr = &*self.evq as *const (EventFifo,AtomicBool);
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_set_user_data, self.ptr, ptr as *const c_void as *mut c_void) };
    }
}

impl ::std::fmt::Debug for WlShm {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {
        fmt.write_fmt(format_args!("wayland::wl_shm::{}", self.ptr as usize))
    }
}

/// wl_shm error values
///
/// These errors can be emitted in response to wl_shm requests.
#[repr(u32)]
#[derive(Debug)]
pub enum WlShmError {
    /// buffer format is not known
    InvalidFormat = 0,
    /// invalid size or stride during pool or buffer creation
    InvalidStride = 1,
    /// mmapping the file descriptor failed
    InvalidFd = 2,
}
fn wl_shm_error_from_raw(n: u32) -> Option<WlShmError> {
    match n {
        0 => Some(WlShmError::InvalidFormat),
        1 => Some(WlShmError::InvalidStride),
        2 => Some(WlShmError::InvalidFd),
        _ => None
    }
}

/// pixel formats
///
/// This describes the memory layout of an individual pixel.
///
/// All renderers should support argb8888 and xrgb8888 but any other
/// formats are optional and may not be supported by the particular
/// renderer in use.
#[repr(u32)]
#[derive(Debug)]
pub enum WlShmFormat {
    /// 32-bit ARGB format
    Argb8888 = 0,
    /// 32-bit RGB format
    Xrgb8888 = 1,
    C8 = 0x20203843,
    Rgb332 = 0x38424752,
    Bgr233 = 0x38524742,
    Xrgb4444 = 0x32315258,
    Xbgr4444 = 0x32314258,
    Rgbx4444 = 0x32315852,
    Bgrx4444 = 0x32315842,
    Argb4444 = 0x32315241,
    Abgr4444 = 0x32314241,
    Rgba4444 = 0x32314152,
    Bgra4444 = 0x32314142,
    Xrgb1555 = 0x35315258,
    Xbgr1555 = 0x35314258,
    Rgbx5551 = 0x35315852,
    Bgrx5551 = 0x35315842,
    Argb1555 = 0x35315241,
    Abgr1555 = 0x35314241,
    Rgba5551 = 0x35314152,
    Bgra5551 = 0x35314142,
    Rgb565 = 0x36314752,
    Bgr565 = 0x36314742,
    Rgb888 = 0x34324752,
    Bgr888 = 0x34324742,
    Xbgr8888 = 0x34324258,
    Rgbx8888 = 0x34325852,
    Bgrx8888 = 0x34325842,
    Abgr8888 = 0x34324241,
    Rgba8888 = 0x34324152,
    Bgra8888 = 0x34324142,
    Xrgb2101010 = 0x30335258,
    Xbgr2101010 = 0x30334258,
    Rgbx1010102 = 0x30335852,
    Bgrx1010102 = 0x30335842,
    Argb2101010 = 0x30335241,
    Abgr2101010 = 0x30334241,
    Rgba1010102 = 0x30334152,
    Bgra1010102 = 0x30334142,
    Yuyv = 0x56595559,
    Yvyu = 0x55595659,
    Uyvy = 0x59565955,
    Vyuy = 0x59555956,
    Ayuv = 0x56555941,
    Nv12 = 0x3231564e,
    Nv21 = 0x3132564e,
    Nv16 = 0x3631564e,
    Nv61 = 0x3136564e,
    Yuv410 = 0x39565559,
    Yvu410 = 0x39555659,
    Yuv411 = 0x31315559,
    Yvu411 = 0x31315659,
    Yuv420 = 0x32315559,
    Yvu420 = 0x32315659,
    Yuv422 = 0x36315559,
    Yvu422 = 0x36315659,
    Yuv444 = 0x34325559,
    Yvu444 = 0x34325659,
}
fn wl_shm_format_from_raw(n: u32) -> Option<WlShmFormat> {
    match n {
        0 => Some(WlShmFormat::Argb8888),
        1 => Some(WlShmFormat::Xrgb8888),
        0x20203843 => Some(WlShmFormat::C8),
        0x38424752 => Some(WlShmFormat::Rgb332),
        0x38524742 => Some(WlShmFormat::Bgr233),
        0x32315258 => Some(WlShmFormat::Xrgb4444),
        0x32314258 => Some(WlShmFormat::Xbgr4444),
        0x32315852 => Some(WlShmFormat::Rgbx4444),
        0x32315842 => Some(WlShmFormat::Bgrx4444),
        0x32315241 => Some(WlShmFormat::Argb4444),
        0x32314241 => Some(WlShmFormat::Abgr4444),
        0x32314152 => Some(WlShmFormat::Rgba4444),
        0x32314142 => Some(WlShmFormat::Bgra4444),
        0x35315258 => Some(WlShmFormat::Xrgb1555),
        0x35314258 => Some(WlShmFormat::Xbgr1555),
        0x35315852 => Some(WlShmFormat::Rgbx5551),
        0x35315842 => Some(WlShmFormat::Bgrx5551),
        0x35315241 => Some(WlShmFormat::Argb1555),
        0x35314241 => Some(WlShmFormat::Abgr1555),
        0x35314152 => Some(WlShmFormat::Rgba5551),
        0x35314142 => Some(WlShmFormat::Bgra5551),
        0x36314752 => Some(WlShmFormat::Rgb565),
        0x36314742 => Some(WlShmFormat::Bgr565),
        0x34324752 => Some(WlShmFormat::Rgb888),
        0x34324742 => Some(WlShmFormat::Bgr888),
        0x34324258 => Some(WlShmFormat::Xbgr8888),
        0x34325852 => Some(WlShmFormat::Rgbx8888),
        0x34325842 => Some(WlShmFormat::Bgrx8888),
        0x34324241 => Some(WlShmFormat::Abgr8888),
        0x34324152 => Some(WlShmFormat::Rgba8888),
        0x34324142 => Some(WlShmFormat::Bgra8888),
        0x30335258 => Some(WlShmFormat::Xrgb2101010),
        0x30334258 => Some(WlShmFormat::Xbgr2101010),
        0x30335852 => Some(WlShmFormat::Rgbx1010102),
        0x30335842 => Some(WlShmFormat::Bgrx1010102),
        0x30335241 => Some(WlShmFormat::Argb2101010),
        0x30334241 => Some(WlShmFormat::Abgr2101010),
        0x30334152 => Some(WlShmFormat::Rgba1010102),
        0x30334142 => Some(WlShmFormat::Bgra1010102),
        0x56595559 => Some(WlShmFormat::Yuyv),
        0x55595659 => Some(WlShmFormat::Yvyu),
        0x59565955 => Some(WlShmFormat::Uyvy),
        0x59555956 => Some(WlShmFormat::Vyuy),
        0x56555941 => Some(WlShmFormat::Ayuv),
        0x3231564e => Some(WlShmFormat::Nv12),
        0x3132564e => Some(WlShmFormat::Nv21),
        0x3631564e => Some(WlShmFormat::Nv16),
        0x3136564e => Some(WlShmFormat::Nv61),
        0x39565559 => Some(WlShmFormat::Yuv410),
        0x39555659 => Some(WlShmFormat::Yvu410),
        0x31315559 => Some(WlShmFormat::Yuv411),
        0x31315659 => Some(WlShmFormat::Yvu411),
        0x32315559 => Some(WlShmFormat::Yuv420),
        0x32315659 => Some(WlShmFormat::Yvu420),
        0x36315559 => Some(WlShmFormat::Yuv422),
        0x36315659 => Some(WlShmFormat::Yvu422),
        0x34325559 => Some(WlShmFormat::Yuv444),
        0x34325659 => Some(WlShmFormat::Yvu444),
        _ => None
    }
}

// wl_shm opcodes
const WL_SHM_CREATE_POOL: u32 = 0;

#[derive(Debug)]
pub enum WlShmEvent {
    /// pixel format description
    ///
    /// Informs the client about a valid pixel format that
    /// can be used for buffers. Known formats include
    /// argb8888 and xrgb8888.
    ///
    /// Values: format,
    Format(WlShmFormat,),
}

fn wl_shm_implem(proxy: *mut wl_proxy, opcode: u32, args: *const wl_argument) -> Option<WaylandProtocolEvent> {
    let event = match opcode {
        0 => {
            let arg_0 = unsafe {*(args.offset(0) as *const u32)};
            let arg_0 = match wl_shm_format_from_raw(arg_0 as u32) { Some(a) => a, None => return None };
            Some(WlShmEvent::Format(arg_0,))
        },
        _ => None
    };
    event.map(|event| WaylandProtocolEvent::WlShm(wrap_proxy(proxy), event))
}

impl WlShm {

    /// create a shm pool
    ///
    /// Create a new wl_shm_pool object.
    ///
    /// The pool can be used to create shared memory based buffer
    /// objects.  The server will mmap size bytes of the passed file
    /// descriptor, to use as backing memory for the pool.
    pub fn create_pool(&self, fd: ::std::os::unix::io::RawFd, size: i32,) -> WlShmPool {
        let ptr = unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal_constructor, self.ptr(), WL_SHM_CREATE_POOL, &wl_shm_pool_interface as *const wl_interface
           , ptr::null_mut::<wl_proxy>(), fd, size) };
        let mut proxy: WlShmPool = unsafe { Proxy::from_ptr(ptr) };
        let evt_iter = eventiter_from_internals(self.evq.clone());
        proxy.set_evt_iterator(&evt_iter);
        ::std::mem::forget(evt_iter); // Don't run the destructor !
        proxy
    }
}

impl Drop for WlShm {
    fn drop(&mut self) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_destroy, self.ptr()) }
    }
}
//
// interface wl_buffer
//

/// content for a wl_surface
///
/// A buffer provides the content for a wl_surface. Buffers are
/// created through factory interfaces such as wl_drm, wl_shm or
/// similar. It has a width and a height and can be attached to a
/// wl_surface, but the mechanism by which a client provides and
/// updates the contents is defined by the buffer factory interface.
pub struct WlBuffer {
    ptr: *mut wl_proxy,
    evq: Arc<(EventFifo,AtomicBool)>
}

unsafe impl Sync for WlBuffer {}
unsafe impl Send for WlBuffer {}
impl Proxy for WlBuffer {
    fn ptr(&self) -> *mut wl_proxy { self.ptr }
    fn interface() -> *mut wl_interface { unsafe { &mut wl_buffer_interface  as *mut wl_interface } }
    fn interface_name() -> &'static str { "wl_buffer" }
    fn version() -> u32 { 1 }
    fn id(&self) -> ProxyId { ProxyId { id: self.ptr as usize } }
    unsafe fn from_ptr(ptr: *mut wl_proxy) -> WlBuffer {
        ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_add_dispatcher, ptr, event_dispatcher, wl_buffer_implem as *const c_void, ptr::null_mut());
        WlBuffer { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    unsafe fn from_ptr_no_own(ptr: *mut wl_proxy) -> WlBuffer {
        WlBuffer { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    fn set_evt_iterator(&mut self, evt: &EventIterator) {
        self.evq = get_eventiter_internals(evt);
        let ptr = &*self.evq as *const (EventFifo,AtomicBool);
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_set_user_data, self.ptr, ptr as *const c_void as *mut c_void) };
    }
}

impl ::std::fmt::Debug for WlBuffer {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {
        fmt.write_fmt(format_args!("wayland::wl_buffer::{}", self.ptr as usize))
    }
}

// wl_buffer opcodes
const WL_BUFFER_DESTROY: u32 = 0;

#[derive(Debug)]
pub enum WlBufferEvent {
    /// compositor releases buffer
    ///
    /// Sent when this wl_buffer is no longer used by the compositor.
    /// The client is now free to re-use or destroy this buffer and its
    /// backing storage.
    ///
    /// If a client receives a release event before the frame callback
    /// requested in the same wl_surface.commit that attaches this
    /// wl_buffer to a surface, then the client is immediately free to
    /// re-use the buffer and its backing storage, and does not need a
    /// second buffer for the next surface content update. Typically
    /// this is possible, when the compositor maintains a copy of the
    /// wl_surface contents, e.g. as a GL texture. This is an important
    /// optimization for GL(ES) compositors with wl_shm clients.
    Release,
}

fn wl_buffer_implem(proxy: *mut wl_proxy, opcode: u32, args: *const wl_argument) -> Option<WaylandProtocolEvent> {
    let event = match opcode {
        0 => {
            Some(WlBufferEvent::Release)
        },
        _ => None
    };
    event.map(|event| WaylandProtocolEvent::WlBuffer(wrap_proxy(proxy), event))
}

impl WlBuffer {

    /// destroy a buffer
    ///
    /// Destroy a buffer. If and how you need to release the backing
    /// storage is defined by the buffer factory interface.
    ///
    /// For possible side-effects to a surface, see wl_surface.attach.
    pub fn destroy(self,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_BUFFER_DESTROY
           ) };
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_destroy, self.ptr()) }
    }
}

impl Drop for WlBuffer {
    fn drop(&mut self) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_destroy, self.ptr()) }
    }
}
//
// interface wl_data_offer
//

/// offer to transfer data
///
/// A wl_data_offer represents a piece of data offered for transfer
/// by another client (the source client).  It is used by the
/// copy-and-paste and drag-and-drop mechanisms.  The offer
/// describes the different mime types that the data can be
/// converted to and provides the mechanism for transferring the
/// data directly from the source client.
pub struct WlDataOffer {
    ptr: *mut wl_proxy,
    evq: Arc<(EventFifo,AtomicBool)>
}

unsafe impl Sync for WlDataOffer {}
unsafe impl Send for WlDataOffer {}
impl Proxy for WlDataOffer {
    fn ptr(&self) -> *mut wl_proxy { self.ptr }
    fn interface() -> *mut wl_interface { unsafe { &mut wl_data_offer_interface  as *mut wl_interface } }
    fn interface_name() -> &'static str { "wl_data_offer" }
    fn version() -> u32 { 1 }
    fn id(&self) -> ProxyId { ProxyId { id: self.ptr as usize } }
    unsafe fn from_ptr(ptr: *mut wl_proxy) -> WlDataOffer {
        ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_add_dispatcher, ptr, event_dispatcher, wl_data_offer_implem as *const c_void, ptr::null_mut());
        WlDataOffer { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    unsafe fn from_ptr_no_own(ptr: *mut wl_proxy) -> WlDataOffer {
        WlDataOffer { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    fn set_evt_iterator(&mut self, evt: &EventIterator) {
        self.evq = get_eventiter_internals(evt);
        let ptr = &*self.evq as *const (EventFifo,AtomicBool);
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_set_user_data, self.ptr, ptr as *const c_void as *mut c_void) };
    }
}

impl ::std::fmt::Debug for WlDataOffer {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {
        fmt.write_fmt(format_args!("wayland::wl_data_offer::{}", self.ptr as usize))
    }
}

// wl_data_offer opcodes
const WL_DATA_OFFER_ACCEPT: u32 = 0;
const WL_DATA_OFFER_RECEIVE: u32 = 1;
const WL_DATA_OFFER_DESTROY: u32 = 2;

#[derive(Debug)]
pub enum WlDataOfferEvent {
    /// advertise offered mime type
    ///
    /// Sent immediately after creating the wl_data_offer object.  One
    /// event per offered mime type.
    ///
    /// Values: mime_type,
    Offer(String,),
}

fn wl_data_offer_implem(proxy: *mut wl_proxy, opcode: u32, args: *const wl_argument) -> Option<WaylandProtocolEvent> {
    let event = match opcode {
        0 => {
            let arg_0 = unsafe {String::from_utf8_lossy(CStr::from_ptr(*(args.offset(0) as *const *mut c_char)).to_bytes()).into_owned()};
            Some(WlDataOfferEvent::Offer(arg_0,))
        },
        _ => None
    };
    event.map(|event| WaylandProtocolEvent::WlDataOffer(wrap_proxy(proxy), event))
}

impl WlDataOffer {

    /// accept one of the offered mime types
    ///
    /// Indicate that the client can accept the given mime type, or
    /// NULL for not accepted.
    ///
    /// Used for feedback during drag-and-drop.
    pub fn accept(&self, serial: u32, mime_type: Option<String>,) {
        let mime_type = mime_type.map(|t| CString::new(t).unwrap_or_else(|_| panic!("Got a String with interior null.")));
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_DATA_OFFER_ACCEPT
           , serial, mime_type.map(|s| s.as_ptr()).unwrap_or(ptr::null())) };
    }

    /// request that the data is transferred
    ///
    /// To transfer the offered data, the client issues this request
    /// and indicates the mime type it wants to receive.  The transfer
    /// happens through the passed file descriptor (typically created
    /// with the pipe system call).  The source client writes the data
    /// in the mime type representation requested and then closes the
    /// file descriptor.
    ///
    /// The receiving client reads from the read end of the pipe until
    /// EOF and then closes its end, at which point the transfer is
    /// complete.
    pub fn receive(&self, mime_type: String, fd: ::std::os::unix::io::RawFd,) {
        let mime_type = CString::new(mime_type).unwrap_or_else(|_| panic!("Got a String with interior null."));
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_DATA_OFFER_RECEIVE
           , mime_type.as_ptr(), fd) };
    }

    /// destroy data offer
    ///
    /// Destroy the data offer.
    pub fn destroy(self,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_DATA_OFFER_DESTROY
           ) };
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_destroy, self.ptr()) }
    }
}

impl Drop for WlDataOffer {
    fn drop(&mut self) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_destroy, self.ptr()) }
    }
}
//
// interface wl_data_source
//

/// offer to transfer data
///
/// The wl_data_source object is the source side of a wl_data_offer.
/// It is created by the source client in a data transfer and
/// provides a way to describe the offered data and a way to respond
/// to requests to transfer the data.
pub struct WlDataSource {
    ptr: *mut wl_proxy,
    evq: Arc<(EventFifo,AtomicBool)>
}

unsafe impl Sync for WlDataSource {}
unsafe impl Send for WlDataSource {}
impl Proxy for WlDataSource {
    fn ptr(&self) -> *mut wl_proxy { self.ptr }
    fn interface() -> *mut wl_interface { unsafe { &mut wl_data_source_interface  as *mut wl_interface } }
    fn interface_name() -> &'static str { "wl_data_source" }
    fn version() -> u32 { 1 }
    fn id(&self) -> ProxyId { ProxyId { id: self.ptr as usize } }
    unsafe fn from_ptr(ptr: *mut wl_proxy) -> WlDataSource {
        ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_add_dispatcher, ptr, event_dispatcher, wl_data_source_implem as *const c_void, ptr::null_mut());
        WlDataSource { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    unsafe fn from_ptr_no_own(ptr: *mut wl_proxy) -> WlDataSource {
        WlDataSource { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    fn set_evt_iterator(&mut self, evt: &EventIterator) {
        self.evq = get_eventiter_internals(evt);
        let ptr = &*self.evq as *const (EventFifo,AtomicBool);
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_set_user_data, self.ptr, ptr as *const c_void as *mut c_void) };
    }
}

impl ::std::fmt::Debug for WlDataSource {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {
        fmt.write_fmt(format_args!("wayland::wl_data_source::{}", self.ptr as usize))
    }
}

// wl_data_source opcodes
const WL_DATA_SOURCE_OFFER: u32 = 0;
const WL_DATA_SOURCE_DESTROY: u32 = 1;

#[derive(Debug)]
pub enum WlDataSourceEvent {
    /// a target accepts an offered mime type
    ///
    /// Sent when a target accepts pointer_focus or motion events.  If
    /// a target does not accept any of the offered types, type is NULL.
    ///
    /// Used for feedback during drag-and-drop.
    ///
    /// Values: mime_type,
    Target(String,),
    /// send the data
    ///
    /// Request for data from the client.  Send the data as the
    /// specified mime type over the passed file descriptor, then
    /// close it.
    ///
    /// Values: mime_type, fd,
    Send(String,::std::os::unix::io::RawFd,),
    /// selection was cancelled
    ///
    /// This data source has been replaced by another data source.
    /// The client should clean up and destroy this data source.
    Cancelled,
}

fn wl_data_source_implem(proxy: *mut wl_proxy, opcode: u32, args: *const wl_argument) -> Option<WaylandProtocolEvent> {
    let event = match opcode {
        0 => {
            let arg_0 = unsafe {String::from_utf8_lossy(CStr::from_ptr(*(args.offset(0) as *const *mut c_char)).to_bytes()).into_owned()};
            Some(WlDataSourceEvent::Target(arg_0,))
        },
        1 => {
            let arg_0 = unsafe {String::from_utf8_lossy(CStr::from_ptr(*(args.offset(0) as *const *mut c_char)).to_bytes()).into_owned()};
            let arg_1 = unsafe {*(args.offset(1) as *const i32)};
            Some(WlDataSourceEvent::Send(arg_0,arg_1,))
        },
        2 => {
            Some(WlDataSourceEvent::Cancelled)
        },
        _ => None
    };
    event.map(|event| WaylandProtocolEvent::WlDataSource(wrap_proxy(proxy), event))
}

impl WlDataSource {

    /// add an offered mime type
    ///
    /// This request adds a mime type to the set of mime types
    /// advertised to targets.  Can be called several times to offer
    /// multiple types.
    pub fn offer(&self, mime_type: String,) {
        let mime_type = CString::new(mime_type).unwrap_or_else(|_| panic!("Got a String with interior null."));
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_DATA_SOURCE_OFFER
           , mime_type.as_ptr()) };
    }

    /// destroy the data source
    ///
    /// Destroy the data source.
    pub fn destroy(self,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_DATA_SOURCE_DESTROY
           ) };
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_destroy, self.ptr()) }
    }
}

impl Drop for WlDataSource {
    fn drop(&mut self) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_destroy, self.ptr()) }
    }
}
//
// interface wl_data_device
//

/// data transfer device
///
/// There is one wl_data_device per seat which can be obtained
/// from the global wl_data_device_manager singleton.
///
/// A wl_data_device provides access to inter-client data transfer
/// mechanisms such as copy-and-paste and drag-and-drop.
pub struct WlDataDevice {
    ptr: *mut wl_proxy,
    evq: Arc<(EventFifo,AtomicBool)>
}

unsafe impl Sync for WlDataDevice {}
unsafe impl Send for WlDataDevice {}
impl Proxy for WlDataDevice {
    fn ptr(&self) -> *mut wl_proxy { self.ptr }
    fn interface() -> *mut wl_interface { unsafe { &mut wl_data_device_interface  as *mut wl_interface } }
    fn interface_name() -> &'static str { "wl_data_device" }
    fn version() -> u32 { 2 }
    fn id(&self) -> ProxyId { ProxyId { id: self.ptr as usize } }
    unsafe fn from_ptr(ptr: *mut wl_proxy) -> WlDataDevice {
        ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_add_dispatcher, ptr, event_dispatcher, wl_data_device_implem as *const c_void, ptr::null_mut());
        WlDataDevice { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    unsafe fn from_ptr_no_own(ptr: *mut wl_proxy) -> WlDataDevice {
        WlDataDevice { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    fn set_evt_iterator(&mut self, evt: &EventIterator) {
        self.evq = get_eventiter_internals(evt);
        let ptr = &*self.evq as *const (EventFifo,AtomicBool);
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_set_user_data, self.ptr, ptr as *const c_void as *mut c_void) };
    }
}

impl ::std::fmt::Debug for WlDataDevice {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {
        fmt.write_fmt(format_args!("wayland::wl_data_device::{}", self.ptr as usize))
    }
}

#[repr(u32)]
#[derive(Debug)]
pub enum WlDataDeviceError {
    /// given wl_surface has another role
    Role = 0,
    #[doc(hidden)]
    __not_univariant,
}
fn wl_data_device_error_from_raw(n: u32) -> Option<WlDataDeviceError> {
    match n {
        0 => Some(WlDataDeviceError::Role),
        _ => None
    }
}

// wl_data_device opcodes
const WL_DATA_DEVICE_START_DRAG: u32 = 0;
const WL_DATA_DEVICE_SET_SELECTION: u32 = 1;
const WL_DATA_DEVICE_RELEASE: u32 = 2;

#[derive(Debug)]
pub enum WlDataDeviceEvent {
    /// introduce a new wl_data_offer
    ///
    /// The data_offer event introduces a new wl_data_offer object,
    /// which will subsequently be used in either the
    /// data_device.enter event (for drag-and-drop) or the
    /// data_device.selection event (for selections).  Immediately
    /// following the data_device_data_offer event, the new data_offer
    /// object will send out data_offer.offer events to describe the
    /// mime types it offers.
    ///
    /// Values: id,
    DataOffer(WlDataOffer,),
    /// initiate drag-and-drop session
    ///
    /// This event is sent when an active drag-and-drop pointer enters
    /// a surface owned by the client.  The position of the pointer at
    /// enter time is provided by the x and y arguments, in surface
    /// local coordinates.
    ///
    /// Values: serial, surface, x, y, id,
    Enter(u32,ProxyId,f64,f64,ProxyId,),
    /// end drag-and-drop session
    ///
    /// This event is sent when the drag-and-drop pointer leaves the
    /// surface and the session ends.  The client must destroy the
    /// wl_data_offer introduced at enter time at this point.
    Leave,
    /// drag-and-drop session motion
    ///
    /// This event is sent when the drag-and-drop pointer moves within
    /// the currently focused surface. The new position of the pointer
    /// is provided by the x and y arguments, in surface local
    /// coordinates.
    ///
    /// Values: time, x, y,
    Motion(u32,f64,f64,),
    /// end drag-and-drag session successfully
    ///
    /// The event is sent when a drag-and-drop operation is ended
    /// because the implicit grab is removed.
    Drop,
    /// advertise new selection
    ///
    /// The selection event is sent out to notify the client of a new
    /// wl_data_offer for the selection for this device.  The
    /// data_device.data_offer and the data_offer.offer events are
    /// sent out immediately before this event to introduce the data
    /// offer object.  The selection event is sent to a client
    /// immediately before receiving keyboard focus and when a new
    /// selection is set while the client has keyboard focus.  The
    /// data_offer is valid until a new data_offer or NULL is received
    /// or until the client loses keyboard focus.  The client must
    /// destroy the previous selection data_offer, if any, upon receiving
    /// this event.
    ///
    /// Values: id,
    Selection(ProxyId,),
}

fn wl_data_device_implem(proxy: *mut wl_proxy, opcode: u32, args: *const wl_argument) -> Option<WaylandProtocolEvent> {
    let event = match opcode {
        0 => {
            let arg_0 = unsafe {{ let ptr = *(args.offset(0) as *const *mut wl_proxy); WlDataOffer::from_ptr(ptr) }};
            Some(WlDataDeviceEvent::DataOffer(arg_0,))
        },
        1 => {
            let arg_0 = unsafe {*(args.offset(0) as *const u32)};
            let arg_1 = unsafe {wrap_proxy(*(args.offset(1) as *const *mut wl_proxy))};
            let arg_2 = unsafe {wl_fixed_to_double(*(args.offset(2) as *const i32))};
            let arg_3 = unsafe {wl_fixed_to_double(*(args.offset(3) as *const i32))};
            let arg_4 = unsafe {wrap_proxy(*(args.offset(4) as *const *mut wl_proxy))};
            Some(WlDataDeviceEvent::Enter(arg_0,arg_1,arg_2,arg_3,arg_4,))
        },
        2 => {
            Some(WlDataDeviceEvent::Leave)
        },
        3 => {
            let arg_0 = unsafe {*(args.offset(0) as *const u32)};
            let arg_1 = unsafe {wl_fixed_to_double(*(args.offset(1) as *const i32))};
            let arg_2 = unsafe {wl_fixed_to_double(*(args.offset(2) as *const i32))};
            Some(WlDataDeviceEvent::Motion(arg_0,arg_1,arg_2,))
        },
        4 => {
            Some(WlDataDeviceEvent::Drop)
        },
        5 => {
            let arg_0 = unsafe {wrap_proxy(*(args.offset(0) as *const *mut wl_proxy))};
            Some(WlDataDeviceEvent::Selection(arg_0,))
        },
        _ => None
    };
    event.map(|event| WaylandProtocolEvent::WlDataDevice(wrap_proxy(proxy), event))
}

impl WlDataDevice {

    /// start drag-and-drop operation
    ///
    /// This request asks the compositor to start a drag-and-drop
    /// operation on behalf of the client.
    ///
    /// The source argument is the data source that provides the data
    /// for the eventual data transfer. If source is NULL, enter, leave
    /// and motion events are sent only to the client that initiated the
    /// drag and the client is expected to handle the data passing
    /// internally.
    ///
    /// The origin surface is the surface where the drag originates and
    /// the client must have an active implicit grab that matches the
    /// serial.
    ///
    /// The icon surface is an optional (can be NULL) surface that
    /// provides an icon to be moved around with the cursor.  Initially,
    /// the top-left corner of the icon surface is placed at the cursor
    /// hotspot, but subsequent wl_surface.attach request can move the
    /// relative position. Attach requests must be confirmed with
    /// wl_surface.commit as usual. The icon surface is given the role of
    /// a drag-and-drop icon. If the icon surface already has another role,
    /// it raises a protocol error.
    ///
    /// The current and pending input regions of the icon wl_surface are
    /// cleared, and wl_surface.set_input_region is ignored until the
    /// wl_surface is no longer used as the icon surface. When the use
    /// as an icon ends, the current and pending input regions become
    /// undefined, and the wl_surface is unmapped.
    pub fn start_drag(&self, source: Option<&WlDataSource>, origin: &WlSurface, icon: Option<&WlSurface>, serial: u32,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_DATA_DEVICE_START_DRAG
           , source.map(Proxy::ptr).unwrap_or(ptr::null_mut()), origin.ptr(), icon.map(Proxy::ptr).unwrap_or(ptr::null_mut()), serial) };
    }

    /// copy data to the selection
    ///
    /// This request asks the compositor to set the selection
    /// to the data from the source on behalf of the client.
    ///
    /// To unset the selection, set the source to NULL.
    pub fn set_selection(&self, source: Option<&WlDataSource>, serial: u32,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_DATA_DEVICE_SET_SELECTION
           , source.map(Proxy::ptr).unwrap_or(ptr::null_mut()), serial) };
    }

    /// destroy data device
    ///
    /// This request destroys the data device.
    ///
    /// Requires interface version `>= 2`.
    pub fn release(self,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_DATA_DEVICE_RELEASE
           ) };
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_destroy, self.ptr()) }
    }
}

impl Drop for WlDataDevice {
    fn drop(&mut self) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_destroy, self.ptr()) }
    }
}
//
// interface wl_data_device_manager
//

/// data transfer interface
///
/// The wl_data_device_manager is a singleton global object that
/// provides access to inter-client data transfer mechanisms such as
/// copy-and-paste and drag-and-drop.  These mechanisms are tied to
/// a wl_seat and this interface lets a client get a wl_data_device
/// corresponding to a wl_seat.
pub struct WlDataDeviceManager {
    ptr: *mut wl_proxy,
    evq: Arc<(EventFifo,AtomicBool)>
}

unsafe impl Sync for WlDataDeviceManager {}
unsafe impl Send for WlDataDeviceManager {}
impl Proxy for WlDataDeviceManager {
    fn ptr(&self) -> *mut wl_proxy { self.ptr }
    fn interface() -> *mut wl_interface { unsafe { &mut wl_data_device_manager_interface  as *mut wl_interface } }
    fn interface_name() -> &'static str { "wl_data_device_manager" }
    fn version() -> u32 { 2 }
    fn id(&self) -> ProxyId { ProxyId { id: self.ptr as usize } }
    unsafe fn from_ptr(ptr: *mut wl_proxy) -> WlDataDeviceManager {
        WlDataDeviceManager { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    unsafe fn from_ptr_no_own(ptr: *mut wl_proxy) -> WlDataDeviceManager {
        WlDataDeviceManager { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    fn set_evt_iterator(&mut self, evt: &EventIterator) {
        self.evq = get_eventiter_internals(evt);
        let ptr = &*self.evq as *const (EventFifo,AtomicBool);
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_set_user_data, self.ptr, ptr as *const c_void as *mut c_void) };
    }
}

impl ::std::fmt::Debug for WlDataDeviceManager {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {
        fmt.write_fmt(format_args!("wayland::wl_data_device_manager::{}", self.ptr as usize))
    }
}

// wl_data_device_manager opcodes
const WL_DATA_DEVICE_MANAGER_CREATE_DATA_SOURCE: u32 = 0;
const WL_DATA_DEVICE_MANAGER_GET_DATA_DEVICE: u32 = 1;

impl WlDataDeviceManager {

    /// create a new data source
    ///
    /// Create a new data source.
    pub fn create_data_source(&self,) -> WlDataSource {
        let ptr = unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal_constructor, self.ptr(), WL_DATA_DEVICE_MANAGER_CREATE_DATA_SOURCE, &wl_data_source_interface as *const wl_interface
           , ptr::null_mut::<wl_proxy>()) };
        let mut proxy: WlDataSource = unsafe { Proxy::from_ptr(ptr) };
        let evt_iter = eventiter_from_internals(self.evq.clone());
        proxy.set_evt_iterator(&evt_iter);
        ::std::mem::forget(evt_iter); // Don't run the destructor !
        proxy
    }

    /// create a new data device
    ///
    /// Create a new data device for a given seat.
    pub fn get_data_device(&self, seat: &WlSeat,) -> WlDataDevice {
        let ptr = unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal_constructor, self.ptr(), WL_DATA_DEVICE_MANAGER_GET_DATA_DEVICE, &wl_data_device_interface as *const wl_interface
           , ptr::null_mut::<wl_proxy>(), seat.ptr()) };
        let mut proxy: WlDataDevice = unsafe { Proxy::from_ptr(ptr) };
        let evt_iter = eventiter_from_internals(self.evq.clone());
        proxy.set_evt_iterator(&evt_iter);
        ::std::mem::forget(evt_iter); // Don't run the destructor !
        proxy
    }
}

impl Drop for WlDataDeviceManager {
    fn drop(&mut self) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_destroy, self.ptr()) }
    }
}
//
// interface wl_shell
//

/// create desktop-style surfaces
///
/// This interface is implemented by servers that provide
/// desktop-style user interfaces.
///
/// It allows clients to associate a wl_shell_surface with
/// a basic surface.
pub struct WlShell {
    ptr: *mut wl_proxy,
    evq: Arc<(EventFifo,AtomicBool)>
}

unsafe impl Sync for WlShell {}
unsafe impl Send for WlShell {}
impl Proxy for WlShell {
    fn ptr(&self) -> *mut wl_proxy { self.ptr }
    fn interface() -> *mut wl_interface { unsafe { &mut wl_shell_interface  as *mut wl_interface } }
    fn interface_name() -> &'static str { "wl_shell" }
    fn version() -> u32 { 1 }
    fn id(&self) -> ProxyId { ProxyId { id: self.ptr as usize } }
    unsafe fn from_ptr(ptr: *mut wl_proxy) -> WlShell {
        WlShell { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    unsafe fn from_ptr_no_own(ptr: *mut wl_proxy) -> WlShell {
        WlShell { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    fn set_evt_iterator(&mut self, evt: &EventIterator) {
        self.evq = get_eventiter_internals(evt);
        let ptr = &*self.evq as *const (EventFifo,AtomicBool);
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_set_user_data, self.ptr, ptr as *const c_void as *mut c_void) };
    }
}

impl ::std::fmt::Debug for WlShell {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {
        fmt.write_fmt(format_args!("wayland::wl_shell::{}", self.ptr as usize))
    }
}

#[repr(u32)]
#[derive(Debug)]
pub enum WlShellError {
    /// given wl_surface has another role
    Role = 0,
    #[doc(hidden)]
    __not_univariant,
}
fn wl_shell_error_from_raw(n: u32) -> Option<WlShellError> {
    match n {
        0 => Some(WlShellError::Role),
        _ => None
    }
}

// wl_shell opcodes
const WL_SHELL_GET_SHELL_SURFACE: u32 = 0;

impl WlShell {

    /// create a shell surface from a surface
    ///
    /// Create a shell surface for an existing surface. This gives
    /// the wl_surface the role of a shell surface. If the wl_surface
    /// already has another role, it raises a protocol error.
    ///
    /// Only one shell surface can be associated with a given surface.
    pub fn get_shell_surface(&self, surface: &WlSurface,) -> WlShellSurface {
        let ptr = unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal_constructor, self.ptr(), WL_SHELL_GET_SHELL_SURFACE, &wl_shell_surface_interface as *const wl_interface
           , ptr::null_mut::<wl_proxy>(), surface.ptr()) };
        let mut proxy: WlShellSurface = unsafe { Proxy::from_ptr(ptr) };
        let evt_iter = eventiter_from_internals(self.evq.clone());
        proxy.set_evt_iterator(&evt_iter);
        ::std::mem::forget(evt_iter); // Don't run the destructor !
        proxy
    }
}

impl Drop for WlShell {
    fn drop(&mut self) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_destroy, self.ptr()) }
    }
}
//
// interface wl_shell_surface
//

/// desktop-style metadata interface
///
/// An interface that may be implemented by a wl_surface, for
/// implementations that provide a desktop-style user interface.
///
/// It provides requests to treat surfaces like toplevel, fullscreen
/// or popup windows, move, resize or maximize them, associate
/// metadata like title and class, etc.
///
/// On the server side the object is automatically destroyed when
/// the related wl_surface is destroyed.  On client side,
/// wl_shell_surface_destroy() must be called before destroying
/// the wl_surface object.
pub struct WlShellSurface {
    ptr: *mut wl_proxy,
    evq: Arc<(EventFifo,AtomicBool)>
}

unsafe impl Sync for WlShellSurface {}
unsafe impl Send for WlShellSurface {}
impl Proxy for WlShellSurface {
    fn ptr(&self) -> *mut wl_proxy { self.ptr }
    fn interface() -> *mut wl_interface { unsafe { &mut wl_shell_surface_interface  as *mut wl_interface } }
    fn interface_name() -> &'static str { "wl_shell_surface" }
    fn version() -> u32 { 1 }
    fn id(&self) -> ProxyId { ProxyId { id: self.ptr as usize } }
    unsafe fn from_ptr(ptr: *mut wl_proxy) -> WlShellSurface {
        ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_add_dispatcher, ptr, event_dispatcher, wl_shell_surface_implem as *const c_void, ptr::null_mut());
        WlShellSurface { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    unsafe fn from_ptr_no_own(ptr: *mut wl_proxy) -> WlShellSurface {
        WlShellSurface { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    fn set_evt_iterator(&mut self, evt: &EventIterator) {
        self.evq = get_eventiter_internals(evt);
        let ptr = &*self.evq as *const (EventFifo,AtomicBool);
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_set_user_data, self.ptr, ptr as *const c_void as *mut c_void) };
    }
}

impl ::std::fmt::Debug for WlShellSurface {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {
        fmt.write_fmt(format_args!("wayland::wl_shell_surface::{}", self.ptr as usize))
    }
}

/// edge values for resizing
///
/// These values are used to indicate which edge of a surface
/// is being dragged in a resize operation. The server may
/// use this information to adapt its behavior, e.g. choose
/// an appropriate cursor image.
pub mod WlShellSurfaceResize {
bitflags! {
    pub flags WlShellSurfaceResize: u32 {
        const None = 0,
        const Top = 1,
        const Bottom = 2,
        const Left = 4,
        const TopLeft = 5,
        const BottomLeft = 6,
        const Right = 8,
        const TopRight = 9,
        const BottomRight = 10,
    }
}
}

fn wl_shell_surface_resize_from_raw(n: u32) -> Option<WlShellSurfaceResize::WlShellSurfaceResize> {
    Some(WlShellSurfaceResize::WlShellSurfaceResize::from_bits_truncate(n))
}

/// details of transient behaviour
///
/// These flags specify details of the expected behaviour
/// of transient surfaces. Used in the set_transient request.
pub mod WlShellSurfaceTransient {
bitflags! {
    pub flags WlShellSurfaceTransient: u32 {
    /// do not set keyboard focus
        const Inactive = 0x1,
    }
}
}

fn wl_shell_surface_transient_from_raw(n: u32) -> Option<WlShellSurfaceTransient::WlShellSurfaceTransient> {
    Some(WlShellSurfaceTransient::WlShellSurfaceTransient::from_bits_truncate(n))
}

/// different method to set the surface fullscreen
///
/// Hints to indicate to the compositor how to deal with a conflict
/// between the dimensions of the surface and the dimensions of the
/// output. The compositor is free to ignore this parameter.
#[repr(u32)]
#[derive(Debug)]
pub enum WlShellSurfaceFullscreenMethod {
    /// no preference, apply default policy
    Default = 0,
    /// scale, preserve the surface's aspect ratio and center on output
    Scale = 1,
    /// switch output mode to the smallest mode that can fit the surface, add black borders to compensate size mismatch
    Driver = 2,
    /// no upscaling, center on output and add black borders to compensate size mismatch
    Fill = 3,
}
fn wl_shell_surface_fullscreen_method_from_raw(n: u32) -> Option<WlShellSurfaceFullscreenMethod> {
    match n {
        0 => Some(WlShellSurfaceFullscreenMethod::Default),
        1 => Some(WlShellSurfaceFullscreenMethod::Scale),
        2 => Some(WlShellSurfaceFullscreenMethod::Driver),
        3 => Some(WlShellSurfaceFullscreenMethod::Fill),
        _ => None
    }
}

// wl_shell_surface opcodes
const WL_SHELL_SURFACE_PONG: u32 = 0;
const WL_SHELL_SURFACE_MOVE: u32 = 1;
const WL_SHELL_SURFACE_RESIZE: u32 = 2;
const WL_SHELL_SURFACE_SET_TOPLEVEL: u32 = 3;
const WL_SHELL_SURFACE_SET_TRANSIENT: u32 = 4;
const WL_SHELL_SURFACE_SET_FULLSCREEN: u32 = 5;
const WL_SHELL_SURFACE_SET_POPUP: u32 = 6;
const WL_SHELL_SURFACE_SET_MAXIMIZED: u32 = 7;
const WL_SHELL_SURFACE_SET_TITLE: u32 = 8;
const WL_SHELL_SURFACE_SET_CLASS: u32 = 9;

#[derive(Debug)]
pub enum WlShellSurfaceEvent {
    /// ping client
    ///
    /// Ping a client to check if it is receiving events and sending
    /// requests. A client is expected to reply with a pong request.
    ///
    /// Values: serial,
    Ping(u32,),
    /// suggest resize
    ///
    /// The configure event asks the client to resize its surface.
    ///
    /// The size is a hint, in the sense that the client is free to
    /// ignore it if it doesn't resize, pick a smaller size (to
    /// satisfy aspect ratio or resize in steps of NxM pixels).
    ///
    /// The edges parameter provides a hint about how the surface
    /// was resized. The client may use this information to decide
    /// how to adjust its content to the new size (e.g. a scrolling
    /// area might adjust its content position to leave the viewable
    /// content unmoved).
    ///
    /// The client is free to dismiss all but the last configure
    /// event it received.
    ///
    /// The width and height arguments specify the size of the window
    /// in surface local coordinates.
    ///
    /// Values: edges, width, height,
    Configure(WlShellSurfaceResize::WlShellSurfaceResize,i32,i32,),
    /// popup interaction is done
    ///
    /// The popup_done event is sent out when a popup grab is broken,
    /// that is, when the user clicks a surface that doesn't belong
    /// to the client owning the popup surface.
    PopupDone,
}

fn wl_shell_surface_implem(proxy: *mut wl_proxy, opcode: u32, args: *const wl_argument) -> Option<WaylandProtocolEvent> {
    let event = match opcode {
        0 => {
            let arg_0 = unsafe {*(args.offset(0) as *const u32)};
            Some(WlShellSurfaceEvent::Ping(arg_0,))
        },
        1 => {
            let arg_0 = unsafe {*(args.offset(0) as *const u32)};
            let arg_0 = match wl_shell_surface_resize_from_raw(arg_0 as u32) { Some(a) => a, None => return None };
            let arg_1 = unsafe {*(args.offset(1) as *const i32)};
            let arg_2 = unsafe {*(args.offset(2) as *const i32)};
            Some(WlShellSurfaceEvent::Configure(arg_0,arg_1,arg_2,))
        },
        2 => {
            Some(WlShellSurfaceEvent::PopupDone)
        },
        _ => None
    };
    event.map(|event| WaylandProtocolEvent::WlShellSurface(wrap_proxy(proxy), event))
}

impl WlShellSurface {

    /// respond to a ping event
    ///
    /// A client must respond to a ping event with a pong request or
    /// the client may be deemed unresponsive.
    pub fn pong(&self, serial: u32,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_SHELL_SURFACE_PONG
           , serial) };
    }

    /// start an interactive move
    ///
    /// Start a pointer-driven move of the surface.
    ///
    /// This request must be used in response to a button press event.
    /// The server may ignore move requests depending on the state of
    /// the surface (e.g. fullscreen or maximized).
    pub fn move_(&self, seat: &WlSeat, serial: u32,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_SHELL_SURFACE_MOVE
           , seat.ptr(), serial) };
    }

    /// start an interactive resize
    ///
    /// Start a pointer-driven resizing of the surface.
    ///
    /// This request must be used in response to a button press event.
    /// The server may ignore resize requests depending on the state of
    /// the surface (e.g. fullscreen or maximized).
    pub fn resize(&self, seat: &WlSeat, serial: u32, edges: WlShellSurfaceResize::WlShellSurfaceResize,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_SHELL_SURFACE_RESIZE
           , seat.ptr(), serial, edges.bits() as u32) };
    }

    /// make the surface a toplevel surface
    ///
    /// Map the surface as a toplevel surface.
    ///
    /// A toplevel surface is not fullscreen, maximized or transient.
    pub fn set_toplevel(&self,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_SHELL_SURFACE_SET_TOPLEVEL
           ) };
    }

    /// make the surface a transient surface
    ///
    /// Map the surface relative to an existing surface.
    ///
    /// The x and y arguments specify the locations of the upper left
    /// corner of the surface relative to the upper left corner of the
    /// parent surface, in surface local coordinates.
    ///
    /// The flags argument controls details of the transient behaviour.
    pub fn set_transient(&self, parent: &WlSurface, x: i32, y: i32, flags: WlShellSurfaceTransient::WlShellSurfaceTransient,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_SHELL_SURFACE_SET_TRANSIENT
           , parent.ptr(), x, y, flags.bits() as u32) };
    }

    /// make the surface a fullscreen surface
    ///
    /// Map the surface as a fullscreen surface.
    ///
    /// If an output parameter is given then the surface will be made
    /// fullscreen on that output. If the client does not specify the
    /// output then the compositor will apply its policy - usually
    /// choosing the output on which the surface has the biggest surface
    /// area.
    ///
    /// The client may specify a method to resolve a size conflict
    /// between the output size and the surface size - this is provided
    /// through the method parameter.
    ///
    /// The framerate parameter is used only when the method is set
    /// to "driver", to indicate the preferred framerate. A value of 0
    /// indicates that the app does not care about framerate.  The
    /// framerate is specified in mHz, that is framerate of 60000 is 60Hz.
    ///
    /// A method of "scale" or "driver" implies a scaling operation of
    /// the surface, either via a direct scaling operation or a change of
    /// the output mode. This will override any kind of output scaling, so
    /// that mapping a surface with a buffer size equal to the mode can
    /// fill the screen independent of buffer_scale.
    ///
    /// A method of "fill" means we don't scale up the buffer, however
    /// any output scale is applied. This means that you may run into
    /// an edge case where the application maps a buffer with the same
    /// size of the output mode but buffer_scale 1 (thus making a
    /// surface larger than the output). In this case it is allowed to
    /// downscale the results to fit the screen.
    ///
    /// The compositor must reply to this request with a configure event
    /// with the dimensions for the output on which the surface will
    /// be made fullscreen.
    pub fn set_fullscreen(&self, method: WlShellSurfaceFullscreenMethod, framerate: u32, output: Option<&WlOutput>,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_SHELL_SURFACE_SET_FULLSCREEN
           , method as u32, framerate, output.map(Proxy::ptr).unwrap_or(ptr::null_mut())) };
    }

    /// make the surface a popup surface
    ///
    /// Map the surface as a popup.
    ///
    /// A popup surface is a transient surface with an added pointer
    /// grab.
    ///
    /// An existing implicit grab will be changed to owner-events mode,
    /// and the popup grab will continue after the implicit grab ends
    /// (i.e. releasing the mouse button does not cause the popup to
    /// be unmapped).
    ///
    /// The popup grab continues until the window is destroyed or a
    /// mouse button is pressed in any other clients window. A click
    /// in any of the clients surfaces is reported as normal, however,
    /// clicks in other clients surfaces will be discarded and trigger
    /// the callback.
    ///
    /// The x and y arguments specify the locations of the upper left
    /// corner of the surface relative to the upper left corner of the
    /// parent surface, in surface local coordinates.
    pub fn set_popup(&self, seat: &WlSeat, serial: u32, parent: &WlSurface, x: i32, y: i32, flags: WlShellSurfaceTransient::WlShellSurfaceTransient,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_SHELL_SURFACE_SET_POPUP
           , seat.ptr(), serial, parent.ptr(), x, y, flags.bits() as u32) };
    }

    /// make the surface a maximized surface
    ///
    /// Map the surface as a maximized surface.
    ///
    /// If an output parameter is given then the surface will be
    /// maximized on that output. If the client does not specify the
    /// output then the compositor will apply its policy - usually
    /// choosing the output on which the surface has the biggest surface
    /// area.
    ///
    /// The compositor will reply with a configure event telling
    /// the expected new surface size. The operation is completed
    /// on the next buffer attach to this surface.
    ///
    /// A maximized surface typically fills the entire output it is
    /// bound to, except for desktop element such as panels. This is
    /// the main difference between a maximized shell surface and a
    /// fullscreen shell surface.
    ///
    /// The details depend on the compositor implementation.
    pub fn set_maximized(&self, output: Option<&WlOutput>,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_SHELL_SURFACE_SET_MAXIMIZED
           , output.map(Proxy::ptr).unwrap_or(ptr::null_mut())) };
    }

    /// set surface title
    ///
    /// Set a short title for the surface.
    ///
    /// This string may be used to identify the surface in a task bar,
    /// window list, or other user interface elements provided by the
    /// compositor.
    ///
    /// The string must be encoded in UTF-8.
    pub fn set_title(&self, title: String,) {
        let title = CString::new(title).unwrap_or_else(|_| panic!("Got a String with interior null."));
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_SHELL_SURFACE_SET_TITLE
           , title.as_ptr()) };
    }

    /// set surface class
    ///
    /// Set a class for the surface.
    ///
    /// The surface class identifies the general class of applications
    /// to which the surface belongs. A common convention is to use the
    /// file name (or the full path if it is a non-standard location) of
    /// the application's .desktop file as the class.
    pub fn set_class(&self, class_: String,) {
        let class_ = CString::new(class_).unwrap_or_else(|_| panic!("Got a String with interior null."));
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_SHELL_SURFACE_SET_CLASS
           , class_.as_ptr()) };
    }
}

impl Drop for WlShellSurface {
    fn drop(&mut self) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_destroy, self.ptr()) }
    }
}
//
// interface wl_surface
//

/// an onscreen surface
///
/// A surface is a rectangular area that is displayed on the screen.
/// It has a location, size and pixel contents.
///
/// The size of a surface (and relative positions on it) is described
/// in surface local coordinates, which may differ from the buffer
/// local coordinates of the pixel content, in case a buffer_transform
/// or a buffer_scale is used.
///
/// A surface without a "role" is fairly useless, a compositor does
/// not know where, when or how to present it. The role is the
/// purpose of a wl_surface. Examples of roles are a cursor for a
/// pointer (as set by wl_pointer.set_cursor), a drag icon
/// (wl_data_device.start_drag), a sub-surface
/// (wl_subcompositor.get_subsurface), and a window as defined by a
/// shell protocol (e.g. wl_shell.get_shell_surface).
///
/// A surface can have only one role at a time. Initially a
/// wl_surface does not have a role. Once a wl_surface is given a
/// role, it is set permanently for the whole lifetime of the
/// wl_surface object. Giving the current role again is allowed,
/// unless explicitly forbidden by the relevant interface
/// specification.
///
/// Surface roles are given by requests in other interfaces such as
/// wl_pointer.set_cursor. The request should explicitly mention
/// that this request gives a role to a wl_surface. Often, this
/// request also creates a new protocol object that represents the
/// role and adds additional functionality to wl_surface. When a
/// client wants to destroy a wl_surface, they must destroy this 'role
/// object' before the wl_surface.
///
/// Destroying the role object does not remove the role from the
/// wl_surface, but it may stop the wl_surface from "playing the role".
/// For instance, if a wl_subsurface object is destroyed, the wl_surface
/// it was created for will be unmapped and forget its position and
/// z-order. It is allowed to create a wl_subsurface for the same
/// wl_surface again, but it is not allowed to use the wl_surface as
/// a cursor (cursor is a different role than sub-surface, and role
/// switching is not allowed).
pub struct WlSurface {
    ptr: *mut wl_proxy,
    evq: Arc<(EventFifo,AtomicBool)>
}

unsafe impl Sync for WlSurface {}
unsafe impl Send for WlSurface {}
impl Proxy for WlSurface {
    fn ptr(&self) -> *mut wl_proxy { self.ptr }
    fn interface() -> *mut wl_interface { unsafe { &mut wl_surface_interface  as *mut wl_interface } }
    fn interface_name() -> &'static str { "wl_surface" }
    fn version() -> u32 { 3 }
    fn id(&self) -> ProxyId { ProxyId { id: self.ptr as usize } }
    unsafe fn from_ptr(ptr: *mut wl_proxy) -> WlSurface {
        ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_add_dispatcher, ptr, event_dispatcher, wl_surface_implem as *const c_void, ptr::null_mut());
        WlSurface { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    unsafe fn from_ptr_no_own(ptr: *mut wl_proxy) -> WlSurface {
        WlSurface { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    fn set_evt_iterator(&mut self, evt: &EventIterator) {
        self.evq = get_eventiter_internals(evt);
        let ptr = &*self.evq as *const (EventFifo,AtomicBool);
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_set_user_data, self.ptr, ptr as *const c_void as *mut c_void) };
    }
}

impl ::std::fmt::Debug for WlSurface {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {
        fmt.write_fmt(format_args!("wayland::wl_surface::{}", self.ptr as usize))
    }
}

/// wl_surface error values
///
/// These errors can be emitted in response to wl_surface requests.
#[repr(u32)]
#[derive(Debug)]
pub enum WlSurfaceError {
    /// buffer scale value is invalid
    InvalidScale = 0,
    /// buffer transform value is invalid
    InvalidTransform = 1,
}
fn wl_surface_error_from_raw(n: u32) -> Option<WlSurfaceError> {
    match n {
        0 => Some(WlSurfaceError::InvalidScale),
        1 => Some(WlSurfaceError::InvalidTransform),
        _ => None
    }
}

// wl_surface opcodes
const WL_SURFACE_DESTROY: u32 = 0;
const WL_SURFACE_ATTACH: u32 = 1;
const WL_SURFACE_DAMAGE: u32 = 2;
const WL_SURFACE_FRAME: u32 = 3;
const WL_SURFACE_SET_OPAQUE_REGION: u32 = 4;
const WL_SURFACE_SET_INPUT_REGION: u32 = 5;
const WL_SURFACE_COMMIT: u32 = 6;
const WL_SURFACE_SET_BUFFER_TRANSFORM: u32 = 7;
const WL_SURFACE_SET_BUFFER_SCALE: u32 = 8;

#[derive(Debug)]
pub enum WlSurfaceEvent {
    /// surface enters an output
    ///
    /// This is emitted whenever a surface's creation, movement, or resizing
    /// results in some part of it being within the scanout region of an
    /// output.
    ///
    /// Note that a surface may be overlapping with zero or more outputs.
    ///
    /// Values: output,
    Enter(ProxyId,),
    /// surface leaves an output
    ///
    /// This is emitted whenever a surface's creation, movement, or resizing
    /// results in it no longer having any part of it within the scanout region
    /// of an output.
    ///
    /// Values: output,
    Leave(ProxyId,),
}

fn wl_surface_implem(proxy: *mut wl_proxy, opcode: u32, args: *const wl_argument) -> Option<WaylandProtocolEvent> {
    let event = match opcode {
        0 => {
            let arg_0 = unsafe {wrap_proxy(*(args.offset(0) as *const *mut wl_proxy))};
            Some(WlSurfaceEvent::Enter(arg_0,))
        },
        1 => {
            let arg_0 = unsafe {wrap_proxy(*(args.offset(0) as *const *mut wl_proxy))};
            Some(WlSurfaceEvent::Leave(arg_0,))
        },
        _ => None
    };
    event.map(|event| WaylandProtocolEvent::WlSurface(wrap_proxy(proxy), event))
}

impl WlSurface {

    /// delete surface
    ///
    /// Deletes the surface and invalidates its object ID.
    pub fn destroy(self,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_SURFACE_DESTROY
           ) };
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_destroy, self.ptr()) }
    }

    /// set the surface contents
    ///
    /// Set a buffer as the content of this surface.
    ///
    /// The new size of the surface is calculated based on the buffer
    /// size transformed by the inverse buffer_transform and the
    /// inverse buffer_scale. This means that the supplied buffer
    /// must be an integer multiple of the buffer_scale.
    ///
    /// The x and y arguments specify the location of the new pending
    /// buffer's upper left corner, relative to the current buffer's upper
    /// left corner, in surface local coordinates. In other words, the
    /// x and y, combined with the new surface size define in which
    /// directions the surface's size changes.
    ///
    /// Surface contents are double-buffered state, see wl_surface.commit.
    ///
    /// The initial surface contents are void; there is no content.
    /// wl_surface.attach assigns the given wl_buffer as the pending
    /// wl_buffer. wl_surface.commit makes the pending wl_buffer the new
    /// surface contents, and the size of the surface becomes the size
    /// calculated from the wl_buffer, as described above. After commit,
    /// there is no pending buffer until the next attach.
    ///
    /// Committing a pending wl_buffer allows the compositor to read the
    /// pixels in the wl_buffer. The compositor may access the pixels at
    /// any time after the wl_surface.commit request. When the compositor
    /// will not access the pixels anymore, it will send the
    /// wl_buffer.release event. Only after receiving wl_buffer.release,
    /// the client may re-use the wl_buffer. A wl_buffer that has been
    /// attached and then replaced by another attach instead of committed
    /// will not receive a release event, and is not used by the
    /// compositor.
    ///
    /// Destroying the wl_buffer after wl_buffer.release does not change
    /// the surface contents. However, if the client destroys the
    /// wl_buffer before receiving the wl_buffer.release event, the surface
    /// contents become undefined immediately.
    ///
    /// If wl_surface.attach is sent with a NULL wl_buffer, the
    /// following wl_surface.commit will remove the surface content.
    pub fn attach(&self, buffer: Option<&WlBuffer>, x: i32, y: i32,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_SURFACE_ATTACH
           , buffer.map(Proxy::ptr).unwrap_or(ptr::null_mut()), x, y) };
    }

    /// mark part of the surface damaged
    ///
    /// This request is used to describe the regions where the pending
    /// buffer is different from the current surface contents, and where
    /// the surface therefore needs to be repainted. The pending buffer
    /// must be set by wl_surface.attach before sending damage. The
    /// compositor ignores the parts of the damage that fall outside of
    /// the surface.
    ///
    /// Damage is double-buffered state, see wl_surface.commit.
    ///
    /// The damage rectangle is specified in surface local coordinates.
    ///
    /// The initial value for pending damage is empty: no damage.
    /// wl_surface.damage adds pending damage: the new pending damage
    /// is the union of old pending damage and the given rectangle.
    ///
    /// wl_surface.commit assigns pending damage as the current damage,
    /// and clears pending damage. The server will clear the current
    /// damage as it repaints the surface.
    pub fn damage(&self, x: i32, y: i32, width: i32, height: i32,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_SURFACE_DAMAGE
           , x, y, width, height) };
    }

    /// request a frame throttling hint
    ///
    /// Request a notification when it is a good time start drawing a new
    /// frame, by creating a frame callback. This is useful for throttling
    /// redrawing operations, and driving animations.
    ///
    /// When a client is animating on a wl_surface, it can use the 'frame'
    /// request to get notified when it is a good time to draw and commit the
    /// next frame of animation. If the client commits an update earlier than
    /// that, it is likely that some updates will not make it to the display,
    /// and the client is wasting resources by drawing too often.
    ///
    /// The frame request will take effect on the next wl_surface.commit.
    /// The notification will only be posted for one frame unless
    /// requested again. For a wl_surface, the notifications are posted in
    /// the order the frame requests were committed.
    ///
    /// The server must send the notifications so that a client
    /// will not send excessive updates, while still allowing
    /// the highest possible update rate for clients that wait for the reply
    /// before drawing again. The server should give some time for the client
    /// to draw and commit after sending the frame callback events to let them
    /// hit the next output refresh.
    ///
    /// A server should avoid signalling the frame callbacks if the
    /// surface is not visible in any way, e.g. the surface is off-screen,
    /// or completely obscured by other opaque surfaces.
    ///
    /// The object returned by this request will be destroyed by the
    /// compositor after the callback is fired and as such the client must not
    /// attempt to use it after that point.
    ///
    /// The callback_data passed in the callback is the current time, in
    /// milliseconds, with an undefined base.
    pub fn frame(&self,) -> WlCallback {
        let ptr = unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal_constructor, self.ptr(), WL_SURFACE_FRAME, &wl_callback_interface as *const wl_interface
           , ptr::null_mut::<wl_proxy>()) };
        let mut proxy: WlCallback = unsafe { Proxy::from_ptr(ptr) };
        let evt_iter = eventiter_from_internals(self.evq.clone());
        proxy.set_evt_iterator(&evt_iter);
        ::std::mem::forget(evt_iter); // Don't run the destructor !
        proxy
    }

    /// set opaque region
    ///
    /// This request sets the region of the surface that contains
    /// opaque content.
    ///
    /// The opaque region is an optimization hint for the compositor
    /// that lets it optimize out redrawing of content behind opaque
    /// regions.  Setting an opaque region is not required for correct
    /// behaviour, but marking transparent content as opaque will result
    /// in repaint artifacts.
    ///
    /// The opaque region is specified in surface local coordinates.
    ///
    /// The compositor ignores the parts of the opaque region that fall
    /// outside of the surface.
    ///
    /// Opaque region is double-buffered state, see wl_surface.commit.
    ///
    /// wl_surface.set_opaque_region changes the pending opaque region.
    /// wl_surface.commit copies the pending region to the current region.
    /// Otherwise, the pending and current regions are never changed.
    ///
    /// The initial value for opaque region is empty. Setting the pending
    /// opaque region has copy semantics, and the wl_region object can be
    /// destroyed immediately. A NULL wl_region causes the pending opaque
    /// region to be set to empty.
    pub fn set_opaque_region(&self, region: Option<&WlRegion>,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_SURFACE_SET_OPAQUE_REGION
           , region.map(Proxy::ptr).unwrap_or(ptr::null_mut())) };
    }

    /// set input region
    ///
    /// This request sets the region of the surface that can receive
    /// pointer and touch events.
    ///
    /// Input events happening outside of this region will try the next
    /// surface in the server surface stack. The compositor ignores the
    /// parts of the input region that fall outside of the surface.
    ///
    /// The input region is specified in surface local coordinates.
    ///
    /// Input region is double-buffered state, see wl_surface.commit.
    ///
    /// wl_surface.set_input_region changes the pending input region.
    /// wl_surface.commit copies the pending region to the current region.
    /// Otherwise the pending and current regions are never changed,
    /// except cursor and icon surfaces are special cases, see
    /// wl_pointer.set_cursor and wl_data_device.start_drag.
    ///
    /// The initial value for input region is infinite. That means the
    /// whole surface will accept input. Setting the pending input region
    /// has copy semantics, and the wl_region object can be destroyed
    /// immediately. A NULL wl_region causes the input region to be set
    /// to infinite.
    pub fn set_input_region(&self, region: Option<&WlRegion>,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_SURFACE_SET_INPUT_REGION
           , region.map(Proxy::ptr).unwrap_or(ptr::null_mut())) };
    }

    /// commit pending surface state
    ///
    /// Surface state (input, opaque, and damage regions, attached buffers,
    /// etc.) is double-buffered. Protocol requests modify the pending
    /// state, as opposed to current state in use by the compositor. Commit
    /// request atomically applies all pending state, replacing the current
    /// state. After commit, the new pending state is as documented for each
    /// related request.
    ///
    /// On commit, a pending wl_buffer is applied first, all other state
    /// second. This means that all coordinates in double-buffered state are
    /// relative to the new wl_buffer coming into use, except for
    /// wl_surface.attach itself. If there is no pending wl_buffer, the
    /// coordinates are relative to the current surface contents.
    ///
    /// All requests that need a commit to become effective are documented
    /// to affect double-buffered state.
    ///
    /// Other interfaces may add further double-buffered surface state.
    pub fn commit(&self,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_SURFACE_COMMIT
           ) };
    }

    /// sets the buffer transformation
    ///
    /// This request sets an optional transformation on how the compositor
    /// interprets the contents of the buffer attached to the surface. The
    /// accepted values for the transform parameter are the values for
    /// wl_output.transform.
    ///
    /// Buffer transform is double-buffered state, see wl_surface.commit.
    ///
    /// A newly created surface has its buffer transformation set to normal.
    ///
    /// wl_surface.set_buffer_transform changes the pending buffer
    /// transformation. wl_surface.commit copies the pending buffer
    /// transformation to the current one. Otherwise, the pending and current
    /// values are never changed.
    ///
    /// The purpose of this request is to allow clients to render content
    /// according to the output transform, thus permiting the compositor to
    /// use certain optimizations even if the display is rotated. Using
    /// hardware overlays and scanning out a client buffer for fullscreen
    /// surfaces are examples of such optimizations. Those optimizations are
    /// highly dependent on the compositor implementation, so the use of this
    /// request should be considered on a case-by-case basis.
    ///
    /// Note that if the transform value includes 90 or 270 degree rotation,
    /// the width of the buffer will become the surface height and the height
    /// of the buffer will become the surface width.
    ///
    /// If transform is not one of the values from the
    /// wl_output.transform enum the invalid_transform protocol error
    /// is raised.
    ///
    /// Requires interface version `>= 2`.
    pub fn set_buffer_transform(&self, transform: i32,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_SURFACE_SET_BUFFER_TRANSFORM
           , transform) };
    }

    /// sets the buffer scaling factor
    ///
    /// This request sets an optional scaling factor on how the compositor
    /// interprets the contents of the buffer attached to the window.
    ///
    /// Buffer scale is double-buffered state, see wl_surface.commit.
    ///
    /// A newly created surface has its buffer scale set to 1.
    ///
    /// wl_surface.set_buffer_scale changes the pending buffer scale.
    /// wl_surface.commit copies the pending buffer scale to the current one.
    /// Otherwise, the pending and current values are never changed.
    ///
    /// The purpose of this request is to allow clients to supply higher
    /// resolution buffer data for use on high resolution outputs. Its
    /// intended that you pick the same	buffer scale as the scale of the
    /// output that the surface is displayed on.This means the compositor
    /// can avoid scaling when rendering the surface on that output.
    ///
    /// Note that if the scale is larger than 1, then you have to attach
    /// a buffer that is larger (by a factor of scale in each dimension)
    /// than the desired surface size.
    ///
    /// If scale is not positive the invalid_scale protocol error is
    /// raised.
    ///
    /// Requires interface version `>= 3`.
    pub fn set_buffer_scale(&self, scale: i32,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_SURFACE_SET_BUFFER_SCALE
           , scale) };
    }
}

impl Drop for WlSurface {
    fn drop(&mut self) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_destroy, self.ptr()) }
    }
}
//
// interface wl_seat
//

/// group of input devices
///
/// A seat is a group of keyboards, pointer and touch devices. This
/// object is published as a global during start up, or when such a
/// device is hot plugged.  A seat typically has a pointer and
/// maintains a keyboard focus and a pointer focus.
pub struct WlSeat {
    ptr: *mut wl_proxy,
    evq: Arc<(EventFifo,AtomicBool)>
}

unsafe impl Sync for WlSeat {}
unsafe impl Send for WlSeat {}
impl Proxy for WlSeat {
    fn ptr(&self) -> *mut wl_proxy { self.ptr }
    fn interface() -> *mut wl_interface { unsafe { &mut wl_seat_interface  as *mut wl_interface } }
    fn interface_name() -> &'static str { "wl_seat" }
    fn version() -> u32 { 5 }
    fn id(&self) -> ProxyId { ProxyId { id: self.ptr as usize } }
    unsafe fn from_ptr(ptr: *mut wl_proxy) -> WlSeat {
        ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_add_dispatcher, ptr, event_dispatcher, wl_seat_implem as *const c_void, ptr::null_mut());
        WlSeat { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    unsafe fn from_ptr_no_own(ptr: *mut wl_proxy) -> WlSeat {
        WlSeat { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    fn set_evt_iterator(&mut self, evt: &EventIterator) {
        self.evq = get_eventiter_internals(evt);
        let ptr = &*self.evq as *const (EventFifo,AtomicBool);
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_set_user_data, self.ptr, ptr as *const c_void as *mut c_void) };
    }
}

impl ::std::fmt::Debug for WlSeat {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {
        fmt.write_fmt(format_args!("wayland::wl_seat::{}", self.ptr as usize))
    }
}

/// seat capability bitmask
///
/// This is a bitmask of capabilities this seat has; if a member is
/// set, then it is present on the seat.
pub mod WlSeatCapability {
bitflags! {
    pub flags WlSeatCapability: u32 {
    /// The seat has pointer devices
        const Pointer = 1,
    /// The seat has one or more keyboards
        const Keyboard = 2,
    /// The seat has touch devices
        const Touch = 4,
    }
}
}

fn wl_seat_capability_from_raw(n: u32) -> Option<WlSeatCapability::WlSeatCapability> {
    Some(WlSeatCapability::WlSeatCapability::from_bits_truncate(n))
}

// wl_seat opcodes
const WL_SEAT_GET_POINTER: u32 = 0;
const WL_SEAT_GET_KEYBOARD: u32 = 1;
const WL_SEAT_GET_TOUCH: u32 = 2;
const WL_SEAT_RELEASE: u32 = 3;

#[derive(Debug)]
pub enum WlSeatEvent {
    /// seat capabilities changed
    ///
    /// This is emitted whenever a seat gains or loses the pointer,
    /// keyboard or touch capabilities.  The argument is a capability
    /// enum containing the complete set of capabilities this seat has.
    ///
    /// Values: capabilities,
    Capabilities(WlSeatCapability::WlSeatCapability,),
    /// unique identifier for this seat
    ///
    /// In a multiseat configuration this can be used by the client to help
    /// identify which physical devices the seat represents. Based on
    /// the seat configuration used by the compositor.
    ///
    /// Values: name,
    Name(String,),
}

fn wl_seat_implem(proxy: *mut wl_proxy, opcode: u32, args: *const wl_argument) -> Option<WaylandProtocolEvent> {
    let event = match opcode {
        0 => {
            let arg_0 = unsafe {*(args.offset(0) as *const u32)};
            let arg_0 = match wl_seat_capability_from_raw(arg_0 as u32) { Some(a) => a, None => return None };
            Some(WlSeatEvent::Capabilities(arg_0,))
        },
        1 => {
            let arg_0 = unsafe {String::from_utf8_lossy(CStr::from_ptr(*(args.offset(0) as *const *mut c_char)).to_bytes()).into_owned()};
            Some(WlSeatEvent::Name(arg_0,))
        },
        _ => None
    };
    event.map(|event| WaylandProtocolEvent::WlSeat(wrap_proxy(proxy), event))
}

impl WlSeat {

    /// return pointer object
    ///
    /// The ID provided will be initialized to the wl_pointer interface
    /// for this seat.
    ///
    /// This request only takes effect if the seat has the pointer
    /// capability.
    pub fn get_pointer(&self,) -> WlPointer {
        let ptr = unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal_constructor, self.ptr(), WL_SEAT_GET_POINTER, &wl_pointer_interface as *const wl_interface
           , ptr::null_mut::<wl_proxy>()) };
        let mut proxy: WlPointer = unsafe { Proxy::from_ptr(ptr) };
        let evt_iter = eventiter_from_internals(self.evq.clone());
        proxy.set_evt_iterator(&evt_iter);
        ::std::mem::forget(evt_iter); // Don't run the destructor !
        proxy
    }

    /// return keyboard object
    ///
    /// The ID provided will be initialized to the wl_keyboard interface
    /// for this seat.
    ///
    /// This request only takes effect if the seat has the keyboard
    /// capability.
    pub fn get_keyboard(&self,) -> WlKeyboard {
        let ptr = unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal_constructor, self.ptr(), WL_SEAT_GET_KEYBOARD, &wl_keyboard_interface as *const wl_interface
           , ptr::null_mut::<wl_proxy>()) };
        let mut proxy: WlKeyboard = unsafe { Proxy::from_ptr(ptr) };
        let evt_iter = eventiter_from_internals(self.evq.clone());
        proxy.set_evt_iterator(&evt_iter);
        ::std::mem::forget(evt_iter); // Don't run the destructor !
        proxy
    }

    /// return touch object
    ///
    /// The ID provided will be initialized to the wl_touch interface
    /// for this seat.
    ///
    /// This request only takes effect if the seat has the touch
    /// capability.
    pub fn get_touch(&self,) -> WlTouch {
        let ptr = unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal_constructor, self.ptr(), WL_SEAT_GET_TOUCH, &wl_touch_interface as *const wl_interface
           , ptr::null_mut::<wl_proxy>()) };
        let mut proxy: WlTouch = unsafe { Proxy::from_ptr(ptr) };
        let evt_iter = eventiter_from_internals(self.evq.clone());
        proxy.set_evt_iterator(&evt_iter);
        ::std::mem::forget(evt_iter); // Don't run the destructor !
        proxy
    }

    /// release the seat object
    ///
    /// Using this request client can tell the server that it is not going to
    /// use the seat object anymore.
    ///
    /// Requires interface version `>= 5`.
    pub fn release(self,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_SEAT_RELEASE
           ) };
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_destroy, self.ptr()) }
    }
}

impl Drop for WlSeat {
    fn drop(&mut self) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_destroy, self.ptr()) }
    }
}
//
// interface wl_pointer
//

/// pointer input device
///
/// The wl_pointer interface represents one or more input devices,
/// such as mice, which control the pointer location and pointer_focus
/// of a seat.
///
/// The wl_pointer interface generates motion, enter and leave
/// events for the surfaces that the pointer is located over,
/// and button and axis events for button presses, button releases
/// and scrolling.
pub struct WlPointer {
    ptr: *mut wl_proxy,
    evq: Arc<(EventFifo,AtomicBool)>
}

unsafe impl Sync for WlPointer {}
unsafe impl Send for WlPointer {}
impl Proxy for WlPointer {
    fn ptr(&self) -> *mut wl_proxy { self.ptr }
    fn interface() -> *mut wl_interface { unsafe { &mut wl_pointer_interface  as *mut wl_interface } }
    fn interface_name() -> &'static str { "wl_pointer" }
    fn version() -> u32 { 3 }
    fn id(&self) -> ProxyId { ProxyId { id: self.ptr as usize } }
    unsafe fn from_ptr(ptr: *mut wl_proxy) -> WlPointer {
        ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_add_dispatcher, ptr, event_dispatcher, wl_pointer_implem as *const c_void, ptr::null_mut());
        WlPointer { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    unsafe fn from_ptr_no_own(ptr: *mut wl_proxy) -> WlPointer {
        WlPointer { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    fn set_evt_iterator(&mut self, evt: &EventIterator) {
        self.evq = get_eventiter_internals(evt);
        let ptr = &*self.evq as *const (EventFifo,AtomicBool);
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_set_user_data, self.ptr, ptr as *const c_void as *mut c_void) };
    }
}

impl ::std::fmt::Debug for WlPointer {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {
        fmt.write_fmt(format_args!("wayland::wl_pointer::{}", self.ptr as usize))
    }
}

#[repr(u32)]
#[derive(Debug)]
pub enum WlPointerError {
    /// given wl_surface has another role
    Role = 0,
    #[doc(hidden)]
    __not_univariant,
}
fn wl_pointer_error_from_raw(n: u32) -> Option<WlPointerError> {
    match n {
        0 => Some(WlPointerError::Role),
        _ => None
    }
}

/// physical button state
///
/// Describes the physical state of a button which provoked the button
/// event.
#[repr(u32)]
#[derive(Debug)]
pub enum WlPointerButtonState {
    /// The button is not pressed
    Released = 0,
    /// The button is pressed
    Pressed = 1,
}
fn wl_pointer_button_state_from_raw(n: u32) -> Option<WlPointerButtonState> {
    match n {
        0 => Some(WlPointerButtonState::Released),
        1 => Some(WlPointerButtonState::Pressed),
        _ => None
    }
}

/// axis types
///
/// Describes the axis types of scroll events.
#[repr(u32)]
#[derive(Debug)]
pub enum WlPointerAxis {
    VerticalScroll = 0,
    HorizontalScroll = 1,
}
fn wl_pointer_axis_from_raw(n: u32) -> Option<WlPointerAxis> {
    match n {
        0 => Some(WlPointerAxis::VerticalScroll),
        1 => Some(WlPointerAxis::HorizontalScroll),
        _ => None
    }
}

// wl_pointer opcodes
const WL_POINTER_SET_CURSOR: u32 = 0;
const WL_POINTER_RELEASE: u32 = 1;

#[derive(Debug)]
pub enum WlPointerEvent {
    /// enter event
    ///
    /// Notification that this seat's pointer is focused on a certain
    /// surface.
    ///
    /// When an seat's focus enters a surface, the pointer image
    /// is undefined and a client should respond to this event by setting
    /// an appropriate pointer image with the set_cursor request.
    ///
    /// Values: serial, surface, surface_x, surface_y,
    Enter(u32,ProxyId,f64,f64,),
    /// leave event
    ///
    /// Notification that this seat's pointer is no longer focused on
    /// a certain surface.
    ///
    /// The leave notification is sent before the enter notification
    /// for the new focus.
    ///
    /// Values: serial, surface,
    Leave(u32,ProxyId,),
    /// pointer motion event
    ///
    /// Notification of pointer location change. The arguments
    /// surface_x and surface_y are the location relative to the
    /// focused surface.
    ///
    /// Values: time, surface_x, surface_y,
    Motion(u32,f64,f64,),
    /// pointer button event
    ///
    /// Mouse button click and release notifications.
    ///
    /// The location of the click is given by the last motion or
    /// enter event.
    /// The time argument is a timestamp with millisecond
    /// granularity, with an undefined base.
    ///
    /// Values: serial, time, button, state,
    Button(u32,u32,u32,WlPointerButtonState,),
    /// axis event
    ///
    /// Scroll and other axis notifications.
    ///
    /// For scroll events (vertical and horizontal scroll axes), the
    /// value parameter is the length of a vector along the specified
    /// axis in a coordinate space identical to those of motion events,
    /// representing a relative movement along the specified axis.
    ///
    /// For devices that support movements non-parallel to axes multiple
    /// axis events will be emitted.
    ///
    /// When applicable, for example for touch pads, the server can
    /// choose to emit scroll events where the motion vector is
    /// equivalent to a motion event vector.
    ///
    /// When applicable, clients can transform its view relative to the
    /// scroll distance.
    ///
    /// Values: time, axis, value,
    Axis(u32,WlPointerAxis,f64,),
}

fn wl_pointer_implem(proxy: *mut wl_proxy, opcode: u32, args: *const wl_argument) -> Option<WaylandProtocolEvent> {
    let event = match opcode {
        0 => {
            let arg_0 = unsafe {*(args.offset(0) as *const u32)};
            let arg_1 = unsafe {wrap_proxy(*(args.offset(1) as *const *mut wl_proxy))};
            let arg_2 = unsafe {wl_fixed_to_double(*(args.offset(2) as *const i32))};
            let arg_3 = unsafe {wl_fixed_to_double(*(args.offset(3) as *const i32))};
            Some(WlPointerEvent::Enter(arg_0,arg_1,arg_2,arg_3,))
        },
        1 => {
            let arg_0 = unsafe {*(args.offset(0) as *const u32)};
            let arg_1 = unsafe {wrap_proxy(*(args.offset(1) as *const *mut wl_proxy))};
            Some(WlPointerEvent::Leave(arg_0,arg_1,))
        },
        2 => {
            let arg_0 = unsafe {*(args.offset(0) as *const u32)};
            let arg_1 = unsafe {wl_fixed_to_double(*(args.offset(1) as *const i32))};
            let arg_2 = unsafe {wl_fixed_to_double(*(args.offset(2) as *const i32))};
            Some(WlPointerEvent::Motion(arg_0,arg_1,arg_2,))
        },
        3 => {
            let arg_0 = unsafe {*(args.offset(0) as *const u32)};
            let arg_1 = unsafe {*(args.offset(1) as *const u32)};
            let arg_2 = unsafe {*(args.offset(2) as *const u32)};
            let arg_3 = unsafe {*(args.offset(3) as *const u32)};
            let arg_3 = match wl_pointer_button_state_from_raw(arg_3 as u32) { Some(a) => a, None => return None };
            Some(WlPointerEvent::Button(arg_0,arg_1,arg_2,arg_3,))
        },
        4 => {
            let arg_0 = unsafe {*(args.offset(0) as *const u32)};
            let arg_1 = unsafe {*(args.offset(1) as *const u32)};
            let arg_1 = match wl_pointer_axis_from_raw(arg_1 as u32) { Some(a) => a, None => return None };
            let arg_2 = unsafe {wl_fixed_to_double(*(args.offset(2) as *const i32))};
            Some(WlPointerEvent::Axis(arg_0,arg_1,arg_2,))
        },
        _ => None
    };
    event.map(|event| WaylandProtocolEvent::WlPointer(wrap_proxy(proxy), event))
}

impl WlPointer {

    /// set the pointer surface
    ///
    /// Set the pointer surface, i.e., the surface that contains the
    /// pointer image (cursor). This request gives the surface the role
    /// of a cursor. If the surface already has another role, it raises
    /// a protocol error.
    ///
    /// The cursor actually changes only if the pointer
    /// focus for this device is one of the requesting client's surfaces
    /// or the surface parameter is the current pointer surface. If
    /// there was a previous surface set with this request it is
    /// replaced. If surface is NULL, the pointer image is hidden.
    ///
    /// The parameters hotspot_x and hotspot_y define the position of
    /// the pointer surface relative to the pointer location. Its
    /// top-left corner is always at (x, y) - (hotspot_x, hotspot_y),
    /// where (x, y) are the coordinates of the pointer location, in surface
    /// local coordinates.
    ///
    /// On surface.attach requests to the pointer surface, hotspot_x
    /// and hotspot_y are decremented by the x and y parameters
    /// passed to the request. Attach must be confirmed by
    /// wl_surface.commit as usual.
    ///
    /// The hotspot can also be updated by passing the currently set
    /// pointer surface to this request with new values for hotspot_x
    /// and hotspot_y.
    ///
    /// The current and pending input regions of the wl_surface are
    /// cleared, and wl_surface.set_input_region is ignored until the
    /// wl_surface is no longer used as the cursor. When the use as a
    /// cursor ends, the current and pending input regions become
    /// undefined, and the wl_surface is unmapped.
    pub fn set_cursor(&self, serial: u32, surface: Option<&WlSurface>, hotspot_x: i32, hotspot_y: i32,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_POINTER_SET_CURSOR
           , serial, surface.map(Proxy::ptr).unwrap_or(ptr::null_mut()), hotspot_x, hotspot_y) };
    }

    /// release the pointer object
    ///
    /// Using this request client can tell the server that it is not going to
    /// use the pointer object anymore.
    ///
    /// This request destroys the pointer proxy object, so user must not call
    /// wl_pointer_destroy() after using this request.
    ///
    /// Requires interface version `>= 3`.
    pub fn release(self,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_POINTER_RELEASE
           ) };
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_destroy, self.ptr()) }
    }
}

impl Drop for WlPointer {
    fn drop(&mut self) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_destroy, self.ptr()) }
    }
}
//
// interface wl_keyboard
//

/// keyboard input device
///
/// The wl_keyboard interface represents one or more keyboards
/// associated with a seat.
pub struct WlKeyboard {
    ptr: *mut wl_proxy,
    evq: Arc<(EventFifo,AtomicBool)>
}

unsafe impl Sync for WlKeyboard {}
unsafe impl Send for WlKeyboard {}
impl Proxy for WlKeyboard {
    fn ptr(&self) -> *mut wl_proxy { self.ptr }
    fn interface() -> *mut wl_interface { unsafe { &mut wl_keyboard_interface  as *mut wl_interface } }
    fn interface_name() -> &'static str { "wl_keyboard" }
    fn version() -> u32 { 4 }
    fn id(&self) -> ProxyId { ProxyId { id: self.ptr as usize } }
    unsafe fn from_ptr(ptr: *mut wl_proxy) -> WlKeyboard {
        ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_add_dispatcher, ptr, event_dispatcher, wl_keyboard_implem as *const c_void, ptr::null_mut());
        WlKeyboard { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    unsafe fn from_ptr_no_own(ptr: *mut wl_proxy) -> WlKeyboard {
        WlKeyboard { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    fn set_evt_iterator(&mut self, evt: &EventIterator) {
        self.evq = get_eventiter_internals(evt);
        let ptr = &*self.evq as *const (EventFifo,AtomicBool);
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_set_user_data, self.ptr, ptr as *const c_void as *mut c_void) };
    }
}

impl ::std::fmt::Debug for WlKeyboard {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {
        fmt.write_fmt(format_args!("wayland::wl_keyboard::{}", self.ptr as usize))
    }
}

/// keyboard mapping format
///
/// This specifies the format of the keymap provided to the
/// client with the wl_keyboard.keymap event.
#[repr(u32)]
#[derive(Debug)]
pub enum WlKeyboardKeymapFormat {
    /// no keymap; client must understand how to interpret the raw keycode
    NoKeymap = 0,
    /// libxkbcommon compatible; to determine the xkb keycode, clients must add 8 to the key event keycode
    XkbV1 = 1,
}
fn wl_keyboard_keymap_format_from_raw(n: u32) -> Option<WlKeyboardKeymapFormat> {
    match n {
        0 => Some(WlKeyboardKeymapFormat::NoKeymap),
        1 => Some(WlKeyboardKeymapFormat::XkbV1),
        _ => None
    }
}

/// physical key state
///
/// Describes the physical state of a key which provoked the key event.
#[repr(u32)]
#[derive(Debug)]
pub enum WlKeyboardKeyState {
    /// key is not pressed
    Released = 0,
    /// key is pressed
    Pressed = 1,
}
fn wl_keyboard_key_state_from_raw(n: u32) -> Option<WlKeyboardKeyState> {
    match n {
        0 => Some(WlKeyboardKeyState::Released),
        1 => Some(WlKeyboardKeyState::Pressed),
        _ => None
    }
}

// wl_keyboard opcodes
const WL_KEYBOARD_RELEASE: u32 = 0;

#[derive(Debug)]
pub enum WlKeyboardEvent {
    /// keyboard mapping
    ///
    /// This event provides a file descriptor to the client which can be
    /// memory-mapped to provide a keyboard mapping description.
    ///
    /// Values: format, fd, size,
    Keymap(WlKeyboardKeymapFormat,::std::os::unix::io::RawFd,u32,),
    /// enter event
    ///
    /// Notification that this seat's keyboard focus is on a certain
    /// surface.
    ///
    /// Values: serial, surface, keys,
    Enter(u32,ProxyId,Vec<u8>,),
    /// leave event
    ///
    /// Notification that this seat's keyboard focus is no longer on
    /// a certain surface.
    ///
    /// The leave notification is sent before the enter notification
    /// for the new focus.
    ///
    /// Values: serial, surface,
    Leave(u32,ProxyId,),
    /// key event
    ///
    /// A key was pressed or released.
    /// The time argument is a timestamp with millisecond
    /// granularity, with an undefined base.
    ///
    /// Values: serial, time, key, state,
    Key(u32,u32,u32,WlKeyboardKeyState,),
    /// modifier and group state
    ///
    /// Notifies clients that the modifier and/or group state has
    /// changed, and it should update its local state.
    ///
    /// Values: serial, mods_depressed, mods_latched, mods_locked, group,
    Modifiers(u32,u32,u32,u32,u32,),
    /// repeat rate and delay
    ///
    /// Informs the client about the keyboard's repeat rate and delay.
    ///
    /// This event is sent as soon as the wl_keyboard object has been created,
    /// and is guaranteed to be received by the client before any key press
    /// event.
    ///
    /// Negative values for either rate or delay are illegal. A rate of zero
    /// will disable any repeating (regardless of the value of delay).
    ///
    /// This event can be sent later on as well with a new value if necessary,
    /// so clients should continue listening for the event past the creation
    /// of wl_keyboard.
    ///
    /// Values: rate, delay,
    RepeatInfo(i32,i32,),
}

fn wl_keyboard_implem(proxy: *mut wl_proxy, opcode: u32, args: *const wl_argument) -> Option<WaylandProtocolEvent> {
    let event = match opcode {
        0 => {
            let arg_0 = unsafe {*(args.offset(0) as *const u32)};
            let arg_0 = match wl_keyboard_keymap_format_from_raw(arg_0 as u32) { Some(a) => a, None => return None };
            let arg_1 = unsafe {*(args.offset(1) as *const i32)};
            let arg_2 = unsafe {*(args.offset(2) as *const u32)};
            Some(WlKeyboardEvent::Keymap(arg_0,arg_1,arg_2,))
        },
        1 => {
            let arg_0 = unsafe {*(args.offset(0) as *const u32)};
            let arg_1 = unsafe {wrap_proxy(*(args.offset(1) as *const *mut wl_proxy))};
            let arg_2 = unsafe {{ let array = *(args.offset(2) as *const *mut wl_array); ::std::slice::from_raw_parts((*array).data as *const u8, (*array).size as usize).to_owned() }};
            Some(WlKeyboardEvent::Enter(arg_0,arg_1,arg_2,))
        },
        2 => {
            let arg_0 = unsafe {*(args.offset(0) as *const u32)};
            let arg_1 = unsafe {wrap_proxy(*(args.offset(1) as *const *mut wl_proxy))};
            Some(WlKeyboardEvent::Leave(arg_0,arg_1,))
        },
        3 => {
            let arg_0 = unsafe {*(args.offset(0) as *const u32)};
            let arg_1 = unsafe {*(args.offset(1) as *const u32)};
            let arg_2 = unsafe {*(args.offset(2) as *const u32)};
            let arg_3 = unsafe {*(args.offset(3) as *const u32)};
            let arg_3 = match wl_keyboard_key_state_from_raw(arg_3 as u32) { Some(a) => a, None => return None };
            Some(WlKeyboardEvent::Key(arg_0,arg_1,arg_2,arg_3,))
        },
        4 => {
            let arg_0 = unsafe {*(args.offset(0) as *const u32)};
            let arg_1 = unsafe {*(args.offset(1) as *const u32)};
            let arg_2 = unsafe {*(args.offset(2) as *const u32)};
            let arg_3 = unsafe {*(args.offset(3) as *const u32)};
            let arg_4 = unsafe {*(args.offset(4) as *const u32)};
            Some(WlKeyboardEvent::Modifiers(arg_0,arg_1,arg_2,arg_3,arg_4,))
        },
        5 => {
            let arg_0 = unsafe {*(args.offset(0) as *const i32)};
            let arg_1 = unsafe {*(args.offset(1) as *const i32)};
            Some(WlKeyboardEvent::RepeatInfo(arg_0,arg_1,))
        },
        _ => None
    };
    event.map(|event| WaylandProtocolEvent::WlKeyboard(wrap_proxy(proxy), event))
}

impl WlKeyboard {

    /// release the keyboard object
    ///
    ///
    /// Requires interface version `>= 3`.
    pub fn release(self,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_KEYBOARD_RELEASE
           ) };
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_destroy, self.ptr()) }
    }
}

impl Drop for WlKeyboard {
    fn drop(&mut self) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_destroy, self.ptr()) }
    }
}
//
// interface wl_touch
//

/// touchscreen input device
///
/// The wl_touch interface represents a touchscreen
/// associated with a seat.
///
/// Touch interactions can consist of one or more contacts.
/// For each contact, a series of events is generated, starting
/// with a down event, followed by zero or more motion events,
/// and ending with an up event. Events relating to the same
/// contact point can be identified by the ID of the sequence.
pub struct WlTouch {
    ptr: *mut wl_proxy,
    evq: Arc<(EventFifo,AtomicBool)>
}

unsafe impl Sync for WlTouch {}
unsafe impl Send for WlTouch {}
impl Proxy for WlTouch {
    fn ptr(&self) -> *mut wl_proxy { self.ptr }
    fn interface() -> *mut wl_interface { unsafe { &mut wl_touch_interface  as *mut wl_interface } }
    fn interface_name() -> &'static str { "wl_touch" }
    fn version() -> u32 { 3 }
    fn id(&self) -> ProxyId { ProxyId { id: self.ptr as usize } }
    unsafe fn from_ptr(ptr: *mut wl_proxy) -> WlTouch {
        ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_add_dispatcher, ptr, event_dispatcher, wl_touch_implem as *const c_void, ptr::null_mut());
        WlTouch { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    unsafe fn from_ptr_no_own(ptr: *mut wl_proxy) -> WlTouch {
        WlTouch { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    fn set_evt_iterator(&mut self, evt: &EventIterator) {
        self.evq = get_eventiter_internals(evt);
        let ptr = &*self.evq as *const (EventFifo,AtomicBool);
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_set_user_data, self.ptr, ptr as *const c_void as *mut c_void) };
    }
}

impl ::std::fmt::Debug for WlTouch {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {
        fmt.write_fmt(format_args!("wayland::wl_touch::{}", self.ptr as usize))
    }
}

// wl_touch opcodes
const WL_TOUCH_RELEASE: u32 = 0;

#[derive(Debug)]
pub enum WlTouchEvent {
    /// touch down event and beginning of a touch sequence
    ///
    /// A new touch point has appeared on the surface. This touch point is
    /// assigned a unique @id. Future events from this touchpoint reference
    /// this ID. The ID ceases to be valid after a touch up event and may be
    /// re-used in the future.
    ///
    /// Values: serial, time, surface, id, x, y,
    Down(u32,u32,ProxyId,i32,f64,f64,),
    /// end of a touch event sequence
    ///
    /// The touch point has disappeared. No further events will be sent for
    /// this touchpoint and the touch point's ID is released and may be
    /// re-used in a future touch down event.
    ///
    /// Values: serial, time, id,
    Up(u32,u32,i32,),
    /// update of touch point coordinates
    ///
    /// A touchpoint has changed coordinates.
    ///
    /// Values: time, id, x, y,
    Motion(u32,i32,f64,f64,),
    /// end of touch frame event
    ///
    /// Indicates the end of a contact point list.
    Frame,
    /// touch session cancelled
    ///
    /// Sent if the compositor decides the touch stream is a global
    /// gesture. No further events are sent to the clients from that
    /// particular gesture. Touch cancellation applies to all touch points
    /// currently active on this client's surface. The client is
    /// responsible for finalizing the touch points, future touch points on
    /// this surface may re-use the touch point ID.
    Cancel,
}

fn wl_touch_implem(proxy: *mut wl_proxy, opcode: u32, args: *const wl_argument) -> Option<WaylandProtocolEvent> {
    let event = match opcode {
        0 => {
            let arg_0 = unsafe {*(args.offset(0) as *const u32)};
            let arg_1 = unsafe {*(args.offset(1) as *const u32)};
            let arg_2 = unsafe {wrap_proxy(*(args.offset(2) as *const *mut wl_proxy))};
            let arg_3 = unsafe {*(args.offset(3) as *const i32)};
            let arg_4 = unsafe {wl_fixed_to_double(*(args.offset(4) as *const i32))};
            let arg_5 = unsafe {wl_fixed_to_double(*(args.offset(5) as *const i32))};
            Some(WlTouchEvent::Down(arg_0,arg_1,arg_2,arg_3,arg_4,arg_5,))
        },
        1 => {
            let arg_0 = unsafe {*(args.offset(0) as *const u32)};
            let arg_1 = unsafe {*(args.offset(1) as *const u32)};
            let arg_2 = unsafe {*(args.offset(2) as *const i32)};
            Some(WlTouchEvent::Up(arg_0,arg_1,arg_2,))
        },
        2 => {
            let arg_0 = unsafe {*(args.offset(0) as *const u32)};
            let arg_1 = unsafe {*(args.offset(1) as *const i32)};
            let arg_2 = unsafe {wl_fixed_to_double(*(args.offset(2) as *const i32))};
            let arg_3 = unsafe {wl_fixed_to_double(*(args.offset(3) as *const i32))};
            Some(WlTouchEvent::Motion(arg_0,arg_1,arg_2,arg_3,))
        },
        3 => {
            Some(WlTouchEvent::Frame)
        },
        4 => {
            Some(WlTouchEvent::Cancel)
        },
        _ => None
    };
    event.map(|event| WaylandProtocolEvent::WlTouch(wrap_proxy(proxy), event))
}

impl WlTouch {

    /// release the touch object
    ///
    ///
    /// Requires interface version `>= 3`.
    pub fn release(self,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_TOUCH_RELEASE
           ) };
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_destroy, self.ptr()) }
    }
}

impl Drop for WlTouch {
    fn drop(&mut self) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_destroy, self.ptr()) }
    }
}
//
// interface wl_output
//

/// compositor output region
///
/// An output describes part of the compositor geometry.  The
/// compositor works in the 'compositor coordinate system' and an
/// output corresponds to rectangular area in that space that is
/// actually visible.  This typically corresponds to a monitor that
/// displays part of the compositor space.  This object is published
/// as global during start up, or when a monitor is hotplugged.
pub struct WlOutput {
    ptr: *mut wl_proxy,
    evq: Arc<(EventFifo,AtomicBool)>
}

unsafe impl Sync for WlOutput {}
unsafe impl Send for WlOutput {}
impl Proxy for WlOutput {
    fn ptr(&self) -> *mut wl_proxy { self.ptr }
    fn interface() -> *mut wl_interface { unsafe { &mut wl_output_interface  as *mut wl_interface } }
    fn interface_name() -> &'static str { "wl_output" }
    fn version() -> u32 { 2 }
    fn id(&self) -> ProxyId { ProxyId { id: self.ptr as usize } }
    unsafe fn from_ptr(ptr: *mut wl_proxy) -> WlOutput {
        ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_add_dispatcher, ptr, event_dispatcher, wl_output_implem as *const c_void, ptr::null_mut());
        WlOutput { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    unsafe fn from_ptr_no_own(ptr: *mut wl_proxy) -> WlOutput {
        WlOutput { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    fn set_evt_iterator(&mut self, evt: &EventIterator) {
        self.evq = get_eventiter_internals(evt);
        let ptr = &*self.evq as *const (EventFifo,AtomicBool);
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_set_user_data, self.ptr, ptr as *const c_void as *mut c_void) };
    }
}

impl ::std::fmt::Debug for WlOutput {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {
        fmt.write_fmt(format_args!("wayland::wl_output::{}", self.ptr as usize))
    }
}

/// subpixel geometry information
///
/// This enumeration describes how the physical
/// pixels on an output are laid out.
#[repr(u32)]
#[derive(Debug)]
pub enum WlOutputSubpixel {
    Unknown = 0,
    None = 1,
    HorizontalRgb = 2,
    HorizontalBgr = 3,
    VerticalRgb = 4,
    VerticalBgr = 5,
}
fn wl_output_subpixel_from_raw(n: u32) -> Option<WlOutputSubpixel> {
    match n {
        0 => Some(WlOutputSubpixel::Unknown),
        1 => Some(WlOutputSubpixel::None),
        2 => Some(WlOutputSubpixel::HorizontalRgb),
        3 => Some(WlOutputSubpixel::HorizontalBgr),
        4 => Some(WlOutputSubpixel::VerticalRgb),
        5 => Some(WlOutputSubpixel::VerticalBgr),
        _ => None
    }
}

/// transform from framebuffer to output
///
/// This describes the transform that a compositor will apply to a
/// surface to compensate for the rotation or mirroring of an
/// output device.
///
/// The flipped values correspond to an initial flip around a
/// vertical axis followed by rotation.
///
/// The purpose is mainly to allow clients render accordingly and
/// tell the compositor, so that for fullscreen surfaces, the
/// compositor will still be able to scan out directly from client
/// surfaces.
#[repr(u32)]
#[derive(Debug)]
pub enum WlOutputTransform {
    Normal = 0,
    T90 = 1,
    T180 = 2,
    T270 = 3,
    Flipped = 4,
    Flipped90 = 5,
    Flipped180 = 6,
    Flipped270 = 7,
}
fn wl_output_transform_from_raw(n: u32) -> Option<WlOutputTransform> {
    match n {
        0 => Some(WlOutputTransform::Normal),
        1 => Some(WlOutputTransform::T90),
        2 => Some(WlOutputTransform::T180),
        3 => Some(WlOutputTransform::T270),
        4 => Some(WlOutputTransform::Flipped),
        5 => Some(WlOutputTransform::Flipped90),
        6 => Some(WlOutputTransform::Flipped180),
        7 => Some(WlOutputTransform::Flipped270),
        _ => None
    }
}

/// mode information
///
/// These flags describe properties of an output mode.
/// They are used in the flags bitfield of the mode event.
pub mod WlOutputMode {
bitflags! {
    pub flags WlOutputMode: u32 {
    /// indicates this is the current mode
        const Current = 0x1,
    /// indicates this is the preferred mode
        const Preferred = 0x2,
    }
}
}

fn wl_output_mode_from_raw(n: u32) -> Option<WlOutputMode::WlOutputMode> {
    Some(WlOutputMode::WlOutputMode::from_bits_truncate(n))
}

// wl_output opcodes
#[derive(Debug)]
pub enum WlOutputEvent {
    /// properties of the output
    ///
    /// The geometry event describes geometric properties of the output.
    /// The event is sent when binding to the output object and whenever
    /// any of the properties change.
    ///
    /// Values: x, y, physical_width, physical_height, subpixel, make, model, transform,
    Geometry(i32,i32,i32,i32,WlOutputSubpixel,String,String,WlOutputTransform,),
    /// advertise available modes for the output
    ///
    /// The mode event describes an available mode for the output.
    ///
    /// The event is sent when binding to the output object and there
    /// will always be one mode, the current mode.  The event is sent
    /// again if an output changes mode, for the mode that is now
    /// current.  In other words, the current mode is always the last
    /// mode that was received with the current flag set.
    ///
    /// The size of a mode is given in physical hardware units of
    /// the output device. This is not necessarily the same as
    /// the output size in the global compositor space. For instance,
    /// the output may be scaled, as described in wl_output.scale,
    /// or transformed , as described in wl_output.transform.
    ///
    /// Values: flags, width, height, refresh,
    Mode(WlOutputMode::WlOutputMode,i32,i32,i32,),
    /// sent all information about output
    ///
    /// This event is sent after all other properties has been
    /// sent after binding to the output object and after any
    /// other property changes done after that. This allows
    /// changes to the output properties to be seen as
    /// atomic, even if they happen via multiple events.
    Done,
    /// output scaling properties
    ///
    /// This event contains scaling geometry information
    /// that is not in the geometry event. It may be sent after
    /// binding the output object or if the output scale changes
    /// later. If it is not sent, the client should assume a
    /// scale of 1.
    ///
    /// A scale larger than 1 means that the compositor will
    /// automatically scale surface buffers by this amount
    /// when rendering. This is used for very high resolution
    /// displays where applications rendering at the native
    /// resolution would be too small to be legible.
    ///
    /// It is intended that scaling aware clients track the
    /// current output of a surface, and if it is on a scaled
    /// output it should use wl_surface.set_buffer_scale with
    /// the scale of the output. That way the compositor can
    /// avoid scaling the surface, and the client can supply
    /// a higher detail image.
    ///
    /// Values: factor,
    Scale(i32,),
}

fn wl_output_implem(proxy: *mut wl_proxy, opcode: u32, args: *const wl_argument) -> Option<WaylandProtocolEvent> {
    let event = match opcode {
        0 => {
            let arg_0 = unsafe {*(args.offset(0) as *const i32)};
            let arg_1 = unsafe {*(args.offset(1) as *const i32)};
            let arg_2 = unsafe {*(args.offset(2) as *const i32)};
            let arg_3 = unsafe {*(args.offset(3) as *const i32)};
            let arg_4 = unsafe {*(args.offset(4) as *const i32)};
            let arg_4 = match wl_output_subpixel_from_raw(arg_4 as u32) { Some(a) => a, None => return None };
            let arg_5 = unsafe {String::from_utf8_lossy(CStr::from_ptr(*(args.offset(5) as *const *mut c_char)).to_bytes()).into_owned()};
            let arg_6 = unsafe {String::from_utf8_lossy(CStr::from_ptr(*(args.offset(6) as *const *mut c_char)).to_bytes()).into_owned()};
            let arg_7 = unsafe {*(args.offset(7) as *const i32)};
            let arg_7 = match wl_output_transform_from_raw(arg_7 as u32) { Some(a) => a, None => return None };
            Some(WlOutputEvent::Geometry(arg_0,arg_1,arg_2,arg_3,arg_4,arg_5,arg_6,arg_7,))
        },
        1 => {
            let arg_0 = unsafe {*(args.offset(0) as *const u32)};
            let arg_0 = match wl_output_mode_from_raw(arg_0 as u32) { Some(a) => a, None => return None };
            let arg_1 = unsafe {*(args.offset(1) as *const i32)};
            let arg_2 = unsafe {*(args.offset(2) as *const i32)};
            let arg_3 = unsafe {*(args.offset(3) as *const i32)};
            Some(WlOutputEvent::Mode(arg_0,arg_1,arg_2,arg_3,))
        },
        2 => {
            Some(WlOutputEvent::Done)
        },
        3 => {
            let arg_0 = unsafe {*(args.offset(0) as *const i32)};
            Some(WlOutputEvent::Scale(arg_0,))
        },
        _ => None
    };
    event.map(|event| WaylandProtocolEvent::WlOutput(wrap_proxy(proxy), event))
}

impl WlOutput {
}

impl Drop for WlOutput {
    fn drop(&mut self) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_destroy, self.ptr()) }
    }
}
//
// interface wl_region
//

/// region interface
///
/// A region object describes an area.
///
/// Region objects are used to describe the opaque and input
/// regions of a surface.
pub struct WlRegion {
    ptr: *mut wl_proxy,
    evq: Arc<(EventFifo,AtomicBool)>
}

unsafe impl Sync for WlRegion {}
unsafe impl Send for WlRegion {}
impl Proxy for WlRegion {
    fn ptr(&self) -> *mut wl_proxy { self.ptr }
    fn interface() -> *mut wl_interface { unsafe { &mut wl_region_interface  as *mut wl_interface } }
    fn interface_name() -> &'static str { "wl_region" }
    fn version() -> u32 { 1 }
    fn id(&self) -> ProxyId { ProxyId { id: self.ptr as usize } }
    unsafe fn from_ptr(ptr: *mut wl_proxy) -> WlRegion {
        WlRegion { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    unsafe fn from_ptr_no_own(ptr: *mut wl_proxy) -> WlRegion {
        WlRegion { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    fn set_evt_iterator(&mut self, evt: &EventIterator) {
        self.evq = get_eventiter_internals(evt);
        let ptr = &*self.evq as *const (EventFifo,AtomicBool);
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_set_user_data, self.ptr, ptr as *const c_void as *mut c_void) };
    }
}

impl ::std::fmt::Debug for WlRegion {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {
        fmt.write_fmt(format_args!("wayland::wl_region::{}", self.ptr as usize))
    }
}

// wl_region opcodes
const WL_REGION_DESTROY: u32 = 0;
const WL_REGION_ADD: u32 = 1;
const WL_REGION_SUBTRACT: u32 = 2;

impl WlRegion {

    /// destroy region
    ///
    /// Destroy the region.  This will invalidate the object ID.
    pub fn destroy(self,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_REGION_DESTROY
           ) };
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_destroy, self.ptr()) }
    }

    /// add rectangle to region
    ///
    /// Add the specified rectangle to the region.
    pub fn add(&self, x: i32, y: i32, width: i32, height: i32,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_REGION_ADD
           , x, y, width, height) };
    }

    /// subtract rectangle from region
    ///
    /// Subtract the specified rectangle from the region.
    pub fn subtract(&self, x: i32, y: i32, width: i32, height: i32,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_REGION_SUBTRACT
           , x, y, width, height) };
    }
}

impl Drop for WlRegion {
    fn drop(&mut self) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_destroy, self.ptr()) }
    }
}
//
// interface wl_subcompositor
//

/// sub-surface compositing
///
/// The global interface exposing sub-surface compositing capabilities.
/// A wl_surface, that has sub-surfaces associated, is called the
/// parent surface. Sub-surfaces can be arbitrarily nested and create
/// a tree of sub-surfaces.
///
/// The root surface in a tree of sub-surfaces is the main
/// surface. The main surface cannot be a sub-surface, because
/// sub-surfaces must always have a parent.
///
/// A main surface with its sub-surfaces forms a (compound) window.
/// For window management purposes, this set of wl_surface objects is
/// to be considered as a single window, and it should also behave as
/// such.
///
/// The aim of sub-surfaces is to offload some of the compositing work
/// within a window from clients to the compositor. A prime example is
/// a video player with decorations and video in separate wl_surface
/// objects. This should allow the compositor to pass YUV video buffer
/// processing to dedicated overlay hardware when possible.
pub struct WlSubcompositor {
    ptr: *mut wl_proxy,
    evq: Arc<(EventFifo,AtomicBool)>
}

unsafe impl Sync for WlSubcompositor {}
unsafe impl Send for WlSubcompositor {}
impl Proxy for WlSubcompositor {
    fn ptr(&self) -> *mut wl_proxy { self.ptr }
    fn interface() -> *mut wl_interface { unsafe { &mut wl_subcompositor_interface  as *mut wl_interface } }
    fn interface_name() -> &'static str { "wl_subcompositor" }
    fn version() -> u32 { 1 }
    fn id(&self) -> ProxyId { ProxyId { id: self.ptr as usize } }
    unsafe fn from_ptr(ptr: *mut wl_proxy) -> WlSubcompositor {
        WlSubcompositor { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    unsafe fn from_ptr_no_own(ptr: *mut wl_proxy) -> WlSubcompositor {
        WlSubcompositor { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    fn set_evt_iterator(&mut self, evt: &EventIterator) {
        self.evq = get_eventiter_internals(evt);
        let ptr = &*self.evq as *const (EventFifo,AtomicBool);
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_set_user_data, self.ptr, ptr as *const c_void as *mut c_void) };
    }
}

impl ::std::fmt::Debug for WlSubcompositor {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {
        fmt.write_fmt(format_args!("wayland::wl_subcompositor::{}", self.ptr as usize))
    }
}

#[repr(u32)]
#[derive(Debug)]
pub enum WlSubcompositorError {
    /// the to-be sub-surface is invalid
    BadSurface = 0,
    #[doc(hidden)]
    __not_univariant,
}
fn wl_subcompositor_error_from_raw(n: u32) -> Option<WlSubcompositorError> {
    match n {
        0 => Some(WlSubcompositorError::BadSurface),
        _ => None
    }
}

// wl_subcompositor opcodes
const WL_SUBCOMPOSITOR_DESTROY: u32 = 0;
const WL_SUBCOMPOSITOR_GET_SUBSURFACE: u32 = 1;

impl WlSubcompositor {

    /// unbind from the subcompositor interface
    ///
    /// Informs the server that the client will not be using this
    /// protocol object anymore. This does not affect any other
    /// objects, wl_subsurface objects included.
    pub fn destroy(self,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_SUBCOMPOSITOR_DESTROY
           ) };
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_destroy, self.ptr()) }
    }

    /// give a surface the role sub-surface
    ///
    /// Create a sub-surface interface for the given surface, and
    /// associate it with the given parent surface. This turns a
    /// plain wl_surface into a sub-surface.
    ///
    /// The to-be sub-surface must not already have another role, and it
    /// must not have an existing wl_subsurface object. Otherwise a protocol
    /// error is raised.
    pub fn get_subsurface(&self, surface: &WlSurface, parent: &WlSurface,) -> WlSubsurface {
        let ptr = unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal_constructor, self.ptr(), WL_SUBCOMPOSITOR_GET_SUBSURFACE, &wl_subsurface_interface as *const wl_interface
           , ptr::null_mut::<wl_proxy>(), surface.ptr(), parent.ptr()) };
        let mut proxy: WlSubsurface = unsafe { Proxy::from_ptr(ptr) };
        let evt_iter = eventiter_from_internals(self.evq.clone());
        proxy.set_evt_iterator(&evt_iter);
        ::std::mem::forget(evt_iter); // Don't run the destructor !
        proxy
    }
}

impl Drop for WlSubcompositor {
    fn drop(&mut self) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_destroy, self.ptr()) }
    }
}
//
// interface wl_subsurface
//

/// sub-surface interface to a wl_surface
///
/// An additional interface to a wl_surface object, which has been
/// made a sub-surface. A sub-surface has one parent surface. A
/// sub-surface's size and position are not limited to that of the parent.
/// Particularly, a sub-surface is not automatically clipped to its
/// parent's area.
///
/// A sub-surface becomes mapped, when a non-NULL wl_buffer is applied
/// and the parent surface is mapped. The order of which one happens
/// first is irrelevant. A sub-surface is hidden if the parent becomes
/// hidden, or if a NULL wl_buffer is applied. These rules apply
/// recursively through the tree of surfaces.
///
/// The behaviour of wl_surface.commit request on a sub-surface
/// depends on the sub-surface's mode. The possible modes are
/// synchronized and desynchronized, see methods
/// wl_subsurface.set_sync and wl_subsurface.set_desync. Synchronized
/// mode caches the wl_surface state to be applied when the parent's
/// state gets applied, and desynchronized mode applies the pending
/// wl_surface state directly. A sub-surface is initially in the
/// synchronized mode.
///
/// Sub-surfaces have also other kind of state, which is managed by
/// wl_subsurface requests, as opposed to wl_surface requests. This
/// state includes the sub-surface position relative to the parent
/// surface (wl_subsurface.set_position), and the stacking order of
/// the parent and its sub-surfaces (wl_subsurface.place_above and
/// .place_below). This state is applied when the parent surface's
/// wl_surface state is applied, regardless of the sub-surface's mode.
/// As the exception, set_sync and set_desync are effective immediately.
///
/// The main surface can be thought to be always in desynchronized mode,
/// since it does not have a parent in the sub-surfaces sense.
///
/// Even if a sub-surface is in desynchronized mode, it will behave as
/// in synchronized mode, if its parent surface behaves as in
/// synchronized mode. This rule is applied recursively throughout the
/// tree of surfaces. This means, that one can set a sub-surface into
/// synchronized mode, and then assume that all its child and grand-child
/// sub-surfaces are synchronized, too, without explicitly setting them.
///
/// If the wl_surface associated with the wl_subsurface is destroyed, the
/// wl_subsurface object becomes inert. Note, that destroying either object
/// takes effect immediately. If you need to synchronize the removal
/// of a sub-surface to the parent surface update, unmap the sub-surface
/// first by attaching a NULL wl_buffer, update parent, and then destroy
/// the sub-surface.
///
/// If the parent wl_surface object is destroyed, the sub-surface is
/// unmapped.
pub struct WlSubsurface {
    ptr: *mut wl_proxy,
    evq: Arc<(EventFifo,AtomicBool)>
}

unsafe impl Sync for WlSubsurface {}
unsafe impl Send for WlSubsurface {}
impl Proxy for WlSubsurface {
    fn ptr(&self) -> *mut wl_proxy { self.ptr }
    fn interface() -> *mut wl_interface { unsafe { &mut wl_subsurface_interface  as *mut wl_interface } }
    fn interface_name() -> &'static str { "wl_subsurface" }
    fn version() -> u32 { 1 }
    fn id(&self) -> ProxyId { ProxyId { id: self.ptr as usize } }
    unsafe fn from_ptr(ptr: *mut wl_proxy) -> WlSubsurface {
        WlSubsurface { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    unsafe fn from_ptr_no_own(ptr: *mut wl_proxy) -> WlSubsurface {
        WlSubsurface { ptr: ptr, evq: Arc::new((EventFifo::new(), AtomicBool::new(false))) }
    }
    fn set_evt_iterator(&mut self, evt: &EventIterator) {
        self.evq = get_eventiter_internals(evt);
        let ptr = &*self.evq as *const (EventFifo,AtomicBool);
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_set_user_data, self.ptr, ptr as *const c_void as *mut c_void) };
    }
}

impl ::std::fmt::Debug for WlSubsurface {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {
        fmt.write_fmt(format_args!("wayland::wl_subsurface::{}", self.ptr as usize))
    }
}

#[repr(u32)]
#[derive(Debug)]
pub enum WlSubsurfaceError {
    /// wl_surface is not a sibling or the parent
    BadSurface = 0,
    #[doc(hidden)]
    __not_univariant,
}
fn wl_subsurface_error_from_raw(n: u32) -> Option<WlSubsurfaceError> {
    match n {
        0 => Some(WlSubsurfaceError::BadSurface),
        _ => None
    }
}

// wl_subsurface opcodes
const WL_SUBSURFACE_DESTROY: u32 = 0;
const WL_SUBSURFACE_SET_POSITION: u32 = 1;
const WL_SUBSURFACE_PLACE_ABOVE: u32 = 2;
const WL_SUBSURFACE_PLACE_BELOW: u32 = 3;
const WL_SUBSURFACE_SET_SYNC: u32 = 4;
const WL_SUBSURFACE_SET_DESYNC: u32 = 5;

impl WlSubsurface {

    /// remove sub-surface interface
    ///
    /// The sub-surface interface is removed from the wl_surface object
    /// that was turned into a sub-surface with
    /// wl_subcompositor.get_subsurface request. The wl_surface's association
    /// to the parent is deleted, and the wl_surface loses its role as
    /// a sub-surface. The wl_surface is unmapped.
    pub fn destroy(self,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_SUBSURFACE_DESTROY
           ) };
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_destroy, self.ptr()) }
    }

    /// reposition the sub-surface
    ///
    /// This schedules a sub-surface position change.
    /// The sub-surface will be moved so, that its origin (top-left
    /// corner pixel) will be at the location x, y of the parent surface
    /// coordinate system. The coordinates are not restricted to the parent
    /// surface area. Negative values are allowed.
    ///
    /// The scheduled coordinates will take effect whenever the state of the
    /// parent surface is applied. When this happens depends on whether the
    /// parent surface is in synchronized mode or not. See
    /// wl_subsurface.set_sync and wl_subsurface.set_desync for details.
    ///
    /// If more than one set_position request is invoked by the client before
    /// the commit of the parent surface, the position of a new request always
    /// replaces the scheduled position from any previous request.
    ///
    /// The initial position is 0, 0.
    pub fn set_position(&self, x: i32, y: i32,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_SUBSURFACE_SET_POSITION
           , x, y) };
    }

    /// restack the sub-surface
    ///
    /// This sub-surface is taken from the stack, and put back just
    /// above the reference surface, changing the z-order of the sub-surfaces.
    /// The reference surface must be one of the sibling surfaces, or the
    /// parent surface. Using any other surface, including this sub-surface,
    /// will cause a protocol error.
    ///
    /// The z-order is double-buffered. Requests are handled in order and
    /// applied immediately to a pending state. The final pending state is
    /// copied to the active state the next time the state of the parent
    /// surface is applied. When this happens depends on whether the parent
    /// surface is in synchronized mode or not. See wl_subsurface.set_sync and
    /// wl_subsurface.set_desync for details.
    ///
    /// A new sub-surface is initially added as the top-most in the stack
    /// of its siblings and parent.
    pub fn place_above(&self, sibling: &WlSurface,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_SUBSURFACE_PLACE_ABOVE
           , sibling.ptr()) };
    }

    /// restack the sub-surface
    ///
    /// The sub-surface is placed just below of the reference surface.
    /// See wl_subsurface.place_above.
    pub fn place_below(&self, sibling: &WlSurface,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_SUBSURFACE_PLACE_BELOW
           , sibling.ptr()) };
    }

    /// set sub-surface to synchronized mode
    ///
    /// Change the commit behaviour of the sub-surface to synchronized
    /// mode, also described as the parent dependent mode.
    ///
    /// In synchronized mode, wl_surface.commit on a sub-surface will
    /// accumulate the committed state in a cache, but the state will
    /// not be applied and hence will not change the compositor output.
    /// The cached state is applied to the sub-surface immediately after
    /// the parent surface's state is applied. This ensures atomic
    /// updates of the parent and all its synchronized sub-surfaces.
    /// Applying the cached state will invalidate the cache, so further
    /// parent surface commits do not (re-)apply old state.
    ///
    /// See wl_subsurface for the recursive effect of this mode.
    pub fn set_sync(&self,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_SUBSURFACE_SET_SYNC
           ) };
    }

    /// set sub-surface to desynchronized mode
    ///
    /// Change the commit behaviour of the sub-surface to desynchronized
    /// mode, also described as independent or freely running mode.
    ///
    /// In desynchronized mode, wl_surface.commit on a sub-surface will
    /// apply the pending state directly, without caching, as happens
    /// normally with a wl_surface. Calling wl_surface.commit on the
    /// parent surface has no effect on the sub-surface's wl_surface
    /// state. This mode allows a sub-surface to be updated on its own.
    ///
    /// If cached state exists when wl_surface.commit is called in
    /// desynchronized mode, the pending state is added to the cached
    /// state, and applied as whole. This invalidates the cache.
    ///
    /// Note: even if a sub-surface is set to desynchronized, a parent
    /// sub-surface may override it to behave as synchronized. For details,
    /// see wl_subsurface.
    ///
    /// If a surface's parent surface behaves as desynchronized, then
    /// the cached state is applied on set_desync.
    pub fn set_desync(&self,) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_marshal, self.ptr(), WL_SUBSURFACE_SET_DESYNC
           ) };
    }
}

impl Drop for WlSubsurface {
    fn drop(&mut self) {
        unsafe { ffi_dispatch!(WAYLAND_CLIENT_HANDLE, wl_proxy_destroy, self.ptr()) }
    }
}
